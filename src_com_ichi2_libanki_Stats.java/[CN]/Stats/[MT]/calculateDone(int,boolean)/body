{
  mType=type;
  mBackwards=true;
  if (reps) {
    mTitle=R.string.stats_review_count;
    mAxisTitles=new int[]{type,R.string.stats_answers};
  }
 else {
    mTitle=R.string.stats_review_time;
  }
  mValueLabels=new int[]{R.string.statistics_learn,R.string.statistics_relearn,R.string.statistics_young,R.string.statistics_mature,R.string.statistics_cram};
  mColors=new int[]{R.color.stats_learn,R.color.stats_relearn,R.color.stats_young,R.color.stats_mature,R.color.stats_cram};
  int num=0;
  int chunk=0;
switch (type) {
case TYPE_MONTH:
    num=30;
  chunk=1;
break;
case TYPE_YEAR:
num=52;
chunk=7;
break;
case TYPE_LIFE:
num=-1;
chunk=30;
break;
}
ArrayList<String> lims=new ArrayList<String>();
if (num != -1) {
lims.add("id > " + ((mCol.getSched().getDayCutoff() - (num * chunk * 86400)) * 1000));
}
String lim=_revlogLimit();
if (lim.length() > 0) {
lims.add(lim);
}
if (lims.size() > 0) {
lim="WHERE " + lims.toString().replace(","," AND ").replaceAll("[\\[\\]]","");
}
 else {
lim="";
}
String ti;
String tf;
if (!reps) {
ti="time/1000";
if (mType == 0) {
tf="/60.0";
mAxisTitles=new int[]{type,R.string.stats_minutes};
}
 else {
tf="/3600.0";
mAxisTitles=new int[]{type,R.string.stats_hours};
}
}
 else {
ti="1";
tf="";
}
ArrayList<double[]> list=new ArrayList<double[]>();
Cursor cur=null;
try {
cur=mCol.getDb().getDatabase().rawQuery("SELECT (cast((id/1000 - " + mCol.getSched().getDayCutoff() + ") / 86400.0 AS INT))/"+ chunk+ " AS day, "+ "sum(CASE WHEN type = 0 THEN "+ ti+ " ELSE 0 END)"+ tf+ ", "+ "sum(CASE WHEN type = 1 AND lastIvl < 21 THEN "+ ti+ " ELSE 0 END)"+ tf+ ", "+ "sum(CASE WHEN type = 1 AND lastIvl >= 21 THEN "+ ti+ " ELSE 0 END)"+ tf+ ", "+ "sum(CASE WHEN type = 2 THEN "+ ti+ " ELSE 0 END)"+ tf+ ", "+ "sum(CASE WHEN type = 3 THEN "+ ti+ " ELSE 0 END)"+ tf+ " FROM revlog "+ lim+ " GROUP BY day ORDER BY day",null);
if (!cur.moveToFirst()) {
return false;
}
while (cur.moveToNext()) {
list.add(new double[]{cur.getDouble(0),cur.getDouble(1),cur.getDouble(4),cur.getDouble(2),cur.getDouble(3),cur.getDouble(5)});
}
}
  finally {
if (cur != null && !cur.isClosed()) {
cur.close();
}
}
mSeriesList=new double[6][list.size()];
for (int i=0; i < list.size(); i++) {
double[] data=list.get(i);
mSeriesList[0][i]=data[0];
mSeriesList[1][i]=data[1] + data[2] + data[3]+ data[4]+ data[5];
mSeriesList[2][i]=data[2] + data[3] + data[4]+ data[5];
mSeriesList[3][i]=data[3] + data[4] + data[5];
mSeriesList[4][i]=data[4] + data[5];
mSeriesList[5][i]=data[5];
}
return true;
}
