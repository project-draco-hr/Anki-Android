{
  try {
    int doneCurrent=0;
    int[] leftCurrent=new int[]{0,0,0};
    String[] cs=new String[]{"new","lrn","rev"};
    long currentDid=0;
    if (counts == null) {
      JSONObject deck=mCol.getDecks().current();
      currentDid=deck.getLong("id");
      for (      String s : cs) {
        doneCurrent+=deck.getJSONArray(s + "Today").getInt(1);
      }
      if (card != null) {
        int idx=countIdx(card);
        leftCurrent[idx]+=idx == 1 ? card.getLeft() / 1000 : 1;
      }
 else {
        reset();
      }
      leftCurrent[0]+=mNewCount;
      leftCurrent[1]+=mLrnCount;
      leftCurrent[2]+=mRevCount;
    }
    if (counts != null || mCachedDeckCounts == null) {
      if (mCachedDeckCounts == null) {
        mCachedDeckCounts=new HashMap<Long,Pair<String[],long[]>>();
      }
      mCachedDeckCounts.clear();
      if (counts == null) {
        counts=deckDueList();
      }
      for (      DeckDueTreeNode d : counts) {
        int done=0;
        JSONObject deck=mCol.getDecks().get(d.did);
        for (        String s : cs) {
          done+=deck.getJSONArray(s + "Today").getInt(1);
        }
        mCachedDeckCounts.put(d.did,new Pair<String[],long[]>(d.names,new long[]{done,d.newCount,d.lrnCount,d.revCount}));
      }
    }
    int doneAll=0;
    int[] leftAll=new int[]{0,0,0};
    for (    Map.Entry<Long,Pair<String[],long[]>> d : mCachedDeckCounts.entrySet()) {
      boolean exclude=d.getKey() == currentDid;
      if (d.getValue().first.length == 1) {
        if (exclude) {
          continue;
        }
        long[] c=d.getValue().second;
        doneAll+=c[0];
        leftAll[0]+=c[1];
        leftAll[1]+=c[2];
        leftAll[2]+=c[3];
      }
 else       if (exclude) {
        long[] c=d.getValue().second;
        doneAll-=c[0];
        leftAll[0]-=c[1];
        leftAll[1]-=c[2];
        leftAll[2]-=c[3];
      }
    }
    doneAll+=doneCurrent;
    leftAll[0]+=leftCurrent[0];
    leftAll[1]+=leftCurrent[1];
    leftAll[2]+=leftCurrent[2];
    int totalAll=doneAll + leftAll[0] + leftAll[1]+ leftAll[2];
    int totalCurrent=doneCurrent + leftCurrent[0] + leftCurrent[1]+ leftCurrent[2];
    float progressCurrent=-1;
    if (totalCurrent != 0) {
      progressCurrent=(float)doneCurrent / (float)totalCurrent;
    }
    float progressTotal=-1;
    if (totalAll != 0) {
      progressTotal=(float)doneAll / (float)totalAll;
    }
    return new float[]{progressCurrent,progressTotal,totalAll - doneAll,eta ? eta(leftAll,false) : -1};
  }
 catch (  JSONException e) {
    throw new RuntimeException(e);
  }
}
