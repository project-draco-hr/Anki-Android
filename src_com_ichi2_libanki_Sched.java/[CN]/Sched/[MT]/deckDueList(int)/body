{
  _checkDay();
  mCol.getDecks().recoverOrphans();
  ArrayList<JSONObject> decks=mCol.getDecks().all();
  Collections.sort(decks,new DeckDueListComparator());
  HashMap<String,Integer[]> lims=new HashMap<String,Integer[]>();
  ArrayList<Object[]> data=new ArrayList<Object[]>();
  try {
    for (    JSONObject deck : decks) {
      String p;
      String[] parts=deck.getString("name").split("::");
      if (parts.length < 2) {
        p="";
      }
 else {
        StringBuilder sb=new StringBuilder();
        for (int i=0; i < parts.length - 1; i++) {
          sb.append(parts[i]);
          if (i < parts.length - 2) {
            sb.append("::");
          }
        }
        p=sb.toString();
      }
      int nlim=_deckNewLimitSingle(deck);
      if (p.length() > 0) {
        nlim=Math.min(nlim,lims.get(p)[0]);
      }
      int newC=_newForDeck(deck.getLong("id"),nlim);
      int lrn=_lrnForDeck(deck.getLong("id"));
      int rlim=_deckRevLimitSingle(deck);
      if (p.length() > 0) {
        rlim=Math.min(rlim,lims.get(p)[1]);
      }
      int rev=_revForDeck(deck.getLong("id"),rlim);
      data.add(new Object[]{deck.getString("name"),deck.getLong("id"),newC,lrn,rev});
      lims.put(deck.getString("name"),new Integer[]{nlim,rlim});
    }
  }
 catch (  JSONException e) {
    throw new RuntimeException(e);
  }
  return data;
}
