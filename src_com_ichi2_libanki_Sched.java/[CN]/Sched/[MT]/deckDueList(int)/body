{
  _checkDay();
  if (mClearOverdue) {
    removeFailed(true);
  }
  mCol.getDecks().recoverOrphans();
  ArrayList<Object[]> dids=new ArrayList<Object[]>();
  for (  JSONObject g : mCol.getDecks().all()) {
    try {
      long did=g.getLong("id");
      int newCount=-1;
      int lrnCount=-1;
      int revCount=-1;
      float matProgress=-1.0f;
      float allProgress=-1.0f;
      if (counts > DECK_INFORMATION_NAMES) {
        LinkedList<Long> ldid=new LinkedList<Long>();
        ldid.add(did);
        for (        Long c : mCol.getDecks().children(did).values()) {
          ldid.add(c);
        }
        String didLimit=Utils.ids2str(ldid);
        newCount=_walkingCount(ldid,Sched.class.getDeclaredMethod("_deckNewLimitSingle",JSONObject.class),Sched.class.getDeclaredMethod("_cntFnNew",long.class,int.class));
        lrnCount=_cntFnLrn(didLimit);
        revCount=_walkingCount(ldid,Sched.class.getDeclaredMethod("_deckRevLimitSingle",JSONObject.class),Sched.class.getDeclaredMethod("_cntFnRev",long.class,int.class));
      }
      dids.add(new Object[]{g.getString("name"),did,newCount,lrnCount,revCount,matProgress,allProgress});
    }
 catch (    JSONException e) {
      throw new RuntimeException(e);
    }
catch (    NoSuchMethodException e) {
      throw new RuntimeException(e);
    }
  }
  Collections.sort(dids,new DeckDueListComparator());
  return dids;
}
