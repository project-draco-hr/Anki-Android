{
  JSONObject conf;
  try {
    conf=_lapseConf(card);
    card.setLastIvl(card.getIvl());
    if (_resched(card)) {
      card.setLapses(card.getLapses() + 1);
      card.setIvl(_nextLapseIvl(card,conf));
      card.setFactor(Math.max(1300,card.getFactor() - 200));
      card.setDue(mToday + card.getIvl());
    }
    int delay=0;
    if (conf.getJSONArray("delays").length() > 0) {
      if (card.getODue() == 0) {
        card.setODue(card.getDue());
      }
      delay=_delayForGrade(conf,0);
      card.setDue((long)(delay + Utils.now()));
      int left=conf.getJSONArray("delays").length();
      card.setLeft(left + _leftToday(conf.getJSONArray("delays"),left) * 1000);
      card.setQueue(1);
      mLrnCount+=card.getLeft() / 1000;
    }
    if (!_checkLeech(card,conf) && conf.getJSONArray("delays").length() > 0) {
      _sortIntoLrn(card.getDue(),card.getId());
      return new Pair<Integer,Boolean>(delay,false);
    }
 else {
      return new Pair<Integer,Boolean>(delay,true);
    }
  }
 catch (  JSONException e) {
    throw new RuntimeException(e);
  }
}
