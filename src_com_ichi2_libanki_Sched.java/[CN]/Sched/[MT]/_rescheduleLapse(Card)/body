{
  JSONObject conf;
  try {
    conf=_lapseConf(card);
    card.setLastIvl(card.getIvl());
    if (_resched(card)) {
      card.setLapses(card.getLapses() + 1);
      card.setIvl(_nextLapseIvl(card,conf));
      card.setFactor(Math.max(1300,card.getFactor() - 200));
      card.setDue(mToday + card.getIvl());
    }
    int delay=0;
    if (_checkLeech(card,conf) && card.getQueue() == -1) {
      return new Pair<Integer,Boolean>(delay,true);
    }
    if (conf.getJSONArray("delays").length() == 0) {
      return new Pair<Integer,Boolean>(delay,false);
    }
    if (card.getODue() == 0) {
      card.setODue(card.getDue());
    }
    delay=_delayForGrade(conf,0);
    card.setDue((long)(delay + Utils.now()));
    if (card.getDue() < mDayCutoff) {
      int left=conf.getJSONArray("delays").length();
      card.setLeft(left + _leftToday(conf.getJSONArray("delays"),left) * 1000);
      mLrnCount+=card.getLeft() / 1000;
      card.setQueue(1);
      _sortIntoLrn(card.getDue(),card.getId());
      return new Pair<Integer,Boolean>(delay,false);
    }
 else {
      long ahead=((card.getDue() - mDayCutoff) / 86400) + 1;
      card.setDue(mToday + ahead);
      card.setQueue(3);
    }
    return new Pair<Integer,Boolean>(delay,true);
  }
 catch (  JSONException e) {
    throw new RuntimeException(e);
  }
}
