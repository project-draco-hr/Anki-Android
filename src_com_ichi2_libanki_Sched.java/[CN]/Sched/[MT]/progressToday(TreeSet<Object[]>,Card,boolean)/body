{
  try {
    int doneCurrent=0;
    int[] leftCurrent=new int[]{0,0,0};
    String[] cs=new String[]{"new","lrn","rev"};
    long currentDid=0;
    if (counts != null || mCachedDeckCounts == null) {
      if (mCachedDeckCounts == null) {
        mCachedDeckCounts=new HashMap<Long,Pair<String[],long[]>>();
      }
      mCachedDeckCounts.clear();
      if (counts == null) {
        counts=(TreeSet<Object[]>)deckCounts()[0];
      }
      int done=0;
      for (      Object[] d : counts) {
        JSONObject deck=mCol.getDecks().get((Long)d[1]);
        for (        String s : cs) {
          done+=deck.getJSONArray(s + "Today").getInt(1);
        }
        mCachedDeckCounts.put((Long)d[1],new Pair<String[],long[]>((String[])d[0],new long[]{done,(Integer)d[2],(Integer)d[3],(Integer)d[4]}));
      }
    }
    if (card != null) {
      JSONObject deck=mCol.getDecks().current();
      currentDid=deck.getLong("id");
      for (      String s : cs) {
        doneCurrent+=deck.getJSONArray(s + "Today").getInt(1);
      }
      int idx=countIdx(card);
      leftCurrent=new int[]{mNewCount + (idx == 1 ? 0 : 1),mLrnCount + (idx == 1 ? card.getLeft() / 1000 : 0),mRevCount + (idx == 1 ? 0 : 1)};
    }
    int doneAll=0;
    int[] leftAll=new int[]{0,0,0};
    for (    Map.Entry<Long,Pair<String[],long[]>> d : mCachedDeckCounts.entrySet()) {
      boolean exclude=d.getKey() == currentDid;
      if (d.getValue().first.length == 1) {
        if (exclude) {
          continue;
        }
        long[] c=d.getValue().second;
        doneAll+=c[0];
        leftAll[0]+=c[1];
        leftAll[1]+=c[2];
        leftAll[2]+=c[3];
      }
 else       if (exclude) {
        long[] c=d.getValue().second;
        doneAll-=c[0];
        leftAll[0]-=c[1];
        leftAll[1]-=c[2];
        leftAll[2]-=c[3];
      }
    }
    doneAll+=doneCurrent;
    leftAll[0]+=leftCurrent[0];
    leftAll[1]+=leftCurrent[1];
    leftAll[2]+=leftCurrent[2];
    int totalAll=doneAll + leftAll[0] + leftAll[1]+ leftAll[2];
    int totalCurrent=doneCurrent + leftCurrent[0] + leftCurrent[1]+ leftCurrent[2];
    float progressCurrent=-1;
    if (totalCurrent != 0) {
      progressCurrent=(float)doneCurrent / (float)totalCurrent;
    }
    float progressTotal=-1;
    if (totalAll != 0) {
      progressTotal=(float)doneAll / (float)totalAll;
    }
    return new float[]{progressCurrent,progressTotal,totalAll - doneAll,eta ? eta(leftAll,false) : -1};
  }
 catch (  JSONException e) {
    throw new RuntimeException(e);
  }
}
