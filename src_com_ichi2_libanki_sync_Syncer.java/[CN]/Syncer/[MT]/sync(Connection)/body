{
  mCol.save();
  mCol.cleanup();
  HttpResponse ret=mServer.meta();
  if (ret == null) {
    return null;
  }
  int returntype=ret.getStatusLine().getStatusCode();
  if (returntype == 403) {
    return new Object[]{"badAuth"};
  }
 else   if (returntype != 200) {
    return new Object[]{"error",returntype,ret.getStatusLine().getReasonPhrase()};
  }
  long rts;
  long lts;
  try {
    mCol.getDb().getDatabase().beginTransaction();
    try {
      JSONArray ra=new JSONArray(mServer.stream2String(ret.getEntity().getContent()));
      mRMod=ra.getLong(0);
      mRScm=ra.getLong(1);
      mMaxUsn=ra.getInt(2);
      rts=ra.getLong(3);
      mMediaUsn=ra.getInt(4);
      JSONArray la=meta();
      mLMod=la.getLong(0);
      mLScm=la.getLong(1);
      mMinUsn=la.getInt(2);
      lts=la.getLong(3);
      long diff=Math.abs(rts - lts);
      if (diff > 300) {
        return new Object[]{"clockOff",diff};
      }
      if (mLMod == mRMod) {
        return new Object[]{"noChanges"};
      }
 else       if (mLScm != mRScm) {
        return new Object[]{"fullSync"};
      }
      mLNewer=mLMod > mRMod;
      publishProgress(con,R.string.sync_deletions_message);
      JSONObject lrem=removed();
      JSONObject o=new JSONObject();
      o.put("minUsn",mMinUsn);
      o.put("lnewer",mLNewer);
      o.put("graves",lrem);
      JSONObject rrem=mServer.start(o);
      if (rrem == null) {
        return null;
      }
      if (rrem.has("errorType")) {
        return new Object[]{"error",rrem.get("errorType"),rrem.get("errorReason")};
      }
      remove(rrem);
      publishProgress(con,R.string.sync_small_objects_message);
      JSONObject lchg=changes();
      JSONObject sch=new JSONObject();
      sch.put("changes",lchg);
      JSONObject rchg=mServer.applyChanges(sch);
      if (rchg == null) {
        return null;
      }
      if (rchg.has("errorType")) {
        return new Object[]{"error",rchg.get("errorType"),rchg.get("errorReason")};
      }
      mergeChanges(lchg,rchg);
      publishProgress(con,R.string.sync_download_chunk);
      while (true) {
        JSONObject chunk=mServer.chunk();
        if (chunk == null) {
          return null;
        }
        if (chunk.has("errorType")) {
          return new Object[]{"error",chunk.get("errorType"),chunk.get("errorReason")};
        }
        applyChunk(chunk);
        if (chunk.getBoolean("done")) {
          break;
        }
      }
      publishProgress(con,R.string.sync_upload_chunk);
      while (true) {
        JSONObject chunk=chunk();
        JSONObject sech=new JSONObject();
        sech.put("chunk",chunk);
        mServer.applyChunk(sech);
        if (chunk.getBoolean("done")) {
          break;
        }
      }
      JSONArray c=sanityCheck();
      JSONArray s=mServer.sanityCheck();
      if (c == null || s == null || s.getString(0).equals("error")) {
        return new Object[]{"sanityCheckError",null};
      }
      boolean error=false;
      for (int i=0; i < s.getJSONArray(0).length(); i++) {
        if (c.getJSONArray(0).getLong(i) != s.getJSONArray(0).getLong(i)) {
          error=true;
        }
      }
      for (int i=1; i < s.length(); i++) {
        if (c.getLong(i) != s.getLong(i)) {
          error=true;
        }
      }
      if (error) {
        return new Object[]{"sanityCheckError","sanity check failed: local: " + c.toString() + ", remote: "+ s.toString()};
      }
      publishProgress(con,R.string.sync_finish_message);
      long mod=mServer.finish();
      if (mod == 0) {
        return new Object[]{"finishError"};
      }
      finish(mod);
      publishProgress(con,R.string.sync_writing_db);
      mCol.getDb().getDatabase().setTransactionSuccessful();
    }
  finally {
      mCol.getDb().getDatabase().endTransaction();
    }
  }
 catch (  JSONException e) {
    throw new RuntimeException(e);
  }
catch (  IllegalStateException e) {
    throw new RuntimeException(e);
  }
catch (  OutOfMemoryError e) {
    AnkiDroidApp.saveExceptionReportFile(e,"Syncer-sync");
    return new Object[]{"OutOfMemoryError"};
  }
catch (  IOException e) {
    AnkiDroidApp.saveExceptionReportFile(e,"Syncer-sync");
    return new Object[]{"IOException"};
  }
  return new Object[]{"success"};
}
