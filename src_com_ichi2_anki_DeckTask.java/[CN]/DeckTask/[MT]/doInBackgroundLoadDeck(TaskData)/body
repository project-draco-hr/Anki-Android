{
  String deckFilename=params[0].getString();
  Log.i(AnkiDroidApp.TAG,"doInBackgroundLoadDeck - deckFilename = " + deckFilename);
  Resources res=AnkiDroidApp.getInstance().getBaseContext().getResources();
  publishProgress(new TaskData(AnkiDroidApp.getInstance().getBaseContext().getResources().getString(R.string.finish_operation)));
  DeckManager.waitForDeckClosingThread(deckFilename);
  int backupResult=BackupManager.RETURN_NULL;
  if (PrefSettings.getSharedPrefs(AnkiDroidApp.getInstance().getBaseContext()).getBoolean("useBackup",true)) {
    publishProgress(new TaskData(res.getString(R.string.backup_deck)));
    backupResult=BackupManager.backupDeck(deckFilename);
  }
  if (BackupManager.getFreeDiscSpace(deckFilename) < (StudyOptions.MIN_FREE_SPACE * 1024 * 1024)) {
    backupResult=BackupManager.RETURN_LOW_SYSTEM_SPACE;
  }
  Log.i(AnkiDroidApp.TAG,"loadDeck - SD card mounted and existent file -> Loading deck...");
  Deck deck=DeckManager.getDeck(deckFilename,true,DeckManager.REQUESTING_ACTIVITY_STUDYOPTIONS);
  if (deck == null) {
    Log.i(AnkiDroidApp.TAG,"The database " + deckFilename + " could not be opened");
    BackupManager.cleanUpAfterBackupCreation(false);
    return new TaskData(DECK_NOT_LOADED);
  }
  BackupManager.cleanUpAfterBackupCreation(true);
  if (deck.hasFinishScheduler()) {
    deck.finishScheduler();
  }
  publishProgress(new TaskData(backupResult));
  return new TaskData(DECK_LOADED);
}
