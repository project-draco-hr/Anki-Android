{
  String deckFilename=params[0].getString();
  Deck oldDeck=params[0].getDeck();
  Resources res=AnkiDroidApp.getInstance().getBaseContext().getResources();
  if (oldDeck != null) {
    publishProgress(new TaskData(res.getString(R.string.close_previous_deck)));
    oldDeck.closeDeck(false);
  }
  int backupResult=BackupManager.RETURN_NULL;
  if (PrefSettings.getSharedPrefs(AnkiDroidApp.getInstance().getBaseContext()).getBoolean("useBackup",true)) {
    publishProgress(new TaskData(res.getString(R.string.backup_deck)));
    backupResult=BackupManager.backupDeck(deckFilename);
  }
  if (BackupManager.getFreeDiscSpace(deckFilename) < (StudyOptions.MIN_FREE_SPACE * 1024 * 1024)) {
    backupResult=BackupManager.RETURN_LOW_SYSTEM_SPACE;
  }
  try {
    Deck deck=Deck.openDeck(deckFilename);
    if (deck == null) {
      BackupManager.cleanUpAfterBackupCreation(false);
      return new TaskData(DECK_NOT_LOADED);
    }
    BackupManager.cleanUpAfterBackupCreation(true);
    if (deck.hasFinishScheduler()) {
      deck.finishScheduler();
    }
    publishProgress(new TaskData(backupResult));
    return new TaskData(DECK_LOADED,deck,null);
  }
 catch (  SQLException e) {
    BackupManager.cleanUpAfterBackupCreation(false);
    return new TaskData(DECK_NOT_LOADED);
  }
catch (  CursorIndexOutOfBoundsException e) {
    return new TaskData(DECK_EMPTY);
  }
catch (  RuntimeException e) {
    return new TaskData(DECK_NOT_LOADED);
  }
}
