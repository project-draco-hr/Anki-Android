{
  mCol.save();
  HttpResponse ret=mServer.meta();
  int returntype=HttpSyncer.getReturnType(ret);
  if (returntype == 403) {
    return new Object[]{"badAuth"};
  }
 else   if (returntype != 200) {
    return new Object[]{"error",returntype,HttpSyncer.getReason(ret)};
  }
  long rts;
  long lts;
  try {
    JSONArray ra=HttpSyncer.getDataJSONArray(ret);
    mRMod=ra.getLong(0);
    mRScm=ra.getLong(1);
    mMaxUsn=ra.getInt(2);
    rts=ra.getLong(3);
    mMediaUsn=ra.getInt(4);
    JSONArray la=meta();
    mLMod=la.getLong(0);
    mLScm=la.getLong(1);
    mMinUsn=la.getInt(2);
    lts=la.getLong(3);
    long diff=Math.abs(rts - lts);
    if (diff > 300) {
      return new Object[]{"clockOff",diff};
    }
    if (mLMod == mRMod) {
      return new Object[]{"noChanges"};
    }
 else     if (mLScm != mRScm) {
      return new Object[]{"fullSync"};
    }
    mLNewer=mLMod > mRMod;
    con.publishProgress(R.string.sync_deletions_message);
    JSONObject lrem=removed();
    JSONObject o=new JSONObject();
    o.put("minUsn",mMinUsn);
    o.put("lnewer",mLNewer);
    o.put("graves",lrem);
    JSONObject rrem=mServer.start(o);
    if (rrem.has("errorType")) {
      return new Object[]{"error",rrem.get("errorType"),rrem.get("errorReason")};
    }
    remove(rrem);
    con.publishProgress(R.string.sync_small_objects_message);
    JSONObject lchg=changes();
    JSONObject sch=new JSONObject();
    sch.put("changes",lchg);
    JSONObject rchg=mServer.applyChanges(sch);
    if (rchg.has("errorType")) {
      return new Object[]{"error",rchg.get("errorType"),rchg.get("errorReason")};
    }
    mergeChanges(lchg,rchg);
    con.publishProgress(R.string.sync_downloading_message);
    long size=0;
    while (true) {
      JSONObject chunk=mServer.chunk();
      if (chunk.has("errorType")) {
        return new Object[]{"error",chunk.get("errorType"),chunk.get("errorReason")};
      }
      size+=chunk.getLong("rSize");
      chunk.remove("rSize");
      if (size > 512) {
        con.publishProgress(R.string.sync_download_size,size / 1024);
      }
      JSONObject pch=new JSONObject();
      pch.put("chunk",chunk);
      applyChunk(pch);
      if (chunk.getBoolean("done")) {
        break;
      }
    }
    con.publishProgress(R.string.sync_uploading_message);
    size=0;
    while (true) {
      JSONObject chunk=chunk();
      JSONObject sech=new JSONObject();
      sech.put("chunk",chunk);
      byte[] b=sech.toString().getBytes();
      size+=b.length;
      if (size > 512) {
        con.publishProgress(R.string.sync_upload_size,size / 1024);
      }
      mServer.applyChunk(new ByteArrayInputStream(b));
      if (chunk.getBoolean("done")) {
        break;
      }
    }
  }
 catch (  JSONException e) {
    throw new RuntimeException(e);
  }
catch (  IllegalStateException e) {
    throw new RuntimeException(e);
  }
  con.publishProgress(R.string.sync_finish_message);
  long mod=mServer.finish();
  if (mod == 0) {
    return new Object[]{"finishError"};
  }
  finish(mod);
  return new Object[]{"success"};
}
