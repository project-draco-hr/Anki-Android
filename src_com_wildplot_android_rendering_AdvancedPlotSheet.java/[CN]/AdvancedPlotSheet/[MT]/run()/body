{
  prepareRunnables();
  operationIsAborted=false;
  pictureIsConstructed=false;
  HashMap<Thread,DrawableDrawingRunnable> allDrawableDirectory=new HashMap<Thread,DrawableDrawingRunnable>();
  this.currentScreen=0;
  Vector<DrawableDrawingRunnable> offFrameDrawables=new Vector<DrawableDrawingRunnable>();
  Vector<DrawableDrawingRunnable> onFrameDrawables=new Vector<DrawableDrawingRunnable>();
  BufferedImage bufferedFrameImage=new BufferedImage(field.width,field.height,BufferedImage.TYPE_INT_ARGB);
  Graphics2D gFrame=bufferedFrameImage.createGraphics();
  gFrame.setClip(field);
  gFrame.setColor(Color.BLACK);
  Thread[] threads=new Thread[this.screenParts.get(currentScreen).getDrawables().size()];
  int i=0;
  if (this.screenParts.get(currentScreen).getDrawables() != null && this.screenParts.get(currentScreen).getDrawables().size() != 0) {
    for (    Drawable draw : this.screenParts.get(currentScreen).getDrawables()) {
      DrawableDrawingRunnable drawableDrawingRunnable=new DrawableDrawingRunnable(draw,field);
      threads[i]=new Thread(drawableDrawingRunnable);
      allDrawableDirectory.put(threads[i],drawableDrawingRunnable);
      threads[i++].start();
      if (!draw.isOnFrame()) {
        offFrameDrawables.add(drawableDrawingRunnable);
      }
 else {
        onFrameDrawables.add(drawableDrawingRunnable);
      }
    }
  }
  Color oldColor=gFrame.getColor();
  if (this.frameThickness > 0) {
    gFrame.setColor(Color.WHITE);
    gFrame.fillRect(0,0,field.width,this.frameThickness);
    gFrame.fillRect(0,this.frameThickness,this.frameThickness,field.height);
    gFrame.fillRect(field.width + 1 - this.frameThickness,this.frameThickness,this.frameThickness + 2,field.height - this.frameThickness);
    gFrame.fillRect(this.frameThickness,field.height - this.frameThickness,field.width - this.frameThickness,this.frameThickness + 1);
    if (isBordered) {
      gFrame.setColor(Color.black);
      gFrame.fillRect(this.frameThickness - borderThickness + 1,this.frameThickness - borderThickness + 1,field.width - 2 * this.frameThickness + 2 * borderThickness - 2,borderThickness);
      gFrame.fillRect(this.frameThickness - borderThickness + 1,field.height - this.frameThickness,field.width - 2 * this.frameThickness + 2 * borderThickness - 2,borderThickness);
      gFrame.fillRect(this.frameThickness - borderThickness + 1,this.frameThickness - borderThickness + 1,borderThickness,field.height - 2 * this.frameThickness + 2 * borderThickness - 2);
      gFrame.fillRect(field.width - this.frameThickness,this.frameThickness - borderThickness + 1,borderThickness,field.height - 2 * this.frameThickness + 2 * borderThickness - 2);
    }
    gFrame.setColor(oldColor);
    FontMetrics fm=gFrame.getFontMetrics();
    float height=fm.getHeight();
    float width=fm.stringWidth(this.title);
    gFrame.drawString(this.title,field.width / 2 - width / 2,this.frameThickness - 10 - height);
  }
  gFrame.dispose();
  boolean finished=true;
  do {
    if (operationIsAborted) {
      if (hasFirstPixelSkipSet) {
        this.reliefDrawer.setPixelSkip(firstPixelSkip);
        this.reliefDrawer.abortAndReset();
      }
      for (      Drawable draw : this.screenParts.get(currentScreen).getDrawables()) {
        draw.abortAndReset();
      }
      for (i=0; i < threads.length; i++) {
        try {
          threads[i].join();
        }
 catch (        InterruptedException e) {
          e.printStackTrace();
        }
      }
      return;
    }
    finished=true;
    for (i=0; i < threads.length; i++) {
      DrawableDrawingRunnable currentDrawableRunnable=allDrawableDirectory.get(threads[i]);
      if (currentDrawableRunnable.hasFinished() || currentDrawableRunnable.getIsCritical()) {
        if (!currentDrawableRunnable.hasJoined()) {
          Drawable drawable=currentDrawableRunnable.getDrawable();
          if (drawable instanceof ReliefDrawer) {
            reliefDrawer=(ReliefDrawer)drawable;
            if (!this.hasFirstPixelSkipSet) {
              this.firstPixelSkip=reliefDrawer.getPixelSkip();
              hasFirstPixelSkipSet=true;
            }
            if (reliefDrawer.getPixelSkip() == 1) {
              try {
                threads[i].join();
              }
 catch (              InterruptedException e) {
                e.printStackTrace();
              }
              currentDrawableRunnable.hasJoined=true;
            }
 else {
              reliefDrawer.setPixelSkip(reliefDrawer.getPixelSkip() - 1);
              try {
                threads[i].join();
              }
 catch (              InterruptedException e) {
                e.printStackTrace();
              }
              BufferedImage oldReliefImage=currentDrawableRunnable.getBufferedDrawableImage();
              currentDrawableRunnable.setBufferedOldDrawableImage(oldReliefImage);
              threads[i]=new Thread(currentDrawableRunnable);
              threads[i].start();
              allDrawableDirectory.put(threads[i],currentDrawableRunnable);
              finished=false;
            }
          }
 else {
            try {
              threads[i].join();
            }
 catch (            InterruptedException e) {
              e.printStackTrace();
            }
            currentDrawableRunnable.hasJoined=true;
          }
        }
      }
 else {
        finished=false;
      }
    }
    BufferedImage buffTempImage=new BufferedImage(field.width,field.height,BufferedImage.TYPE_INT_ARGB);
    Graphics2D g=buffTempImage.createGraphics();
    g.setClip(field);
    for (    DrawableDrawingRunnable offFrameDrawable : offFrameDrawables) {
      if (offFrameDrawable.hasJoined)       g.drawImage(offFrameDrawable.getBufferedDrawableImage(),null,0,0);
 else       if (offFrameDrawable.getBufferedOldDrawableImage() != null)       g.drawImage(offFrameDrawable.getBufferedOldDrawableImage(),null,0,0);
    }
    g.drawImage(bufferedFrameImage,null,0,0);
    for (    DrawableDrawingRunnable onFrameDrawable : onFrameDrawables) {
      if (onFrameDrawable.hasJoined)       g.drawImage(onFrameDrawable.getBufferedDrawableImage(),null,0,0);
 else       if (onFrameDrawable.getBufferedOldDrawableImage() != null)       g.drawImage(onFrameDrawable.getBufferedOldDrawableImage(),null,0,0);
    }
    g.dispose();
    reentrantLock.lock();
    this.plotImage=buffTempImage;
    reentrantLock.unlock();
  }
 while (!finished);
  if (hasFirstPixelSkipSet) {
    this.reliefDrawer.setPixelSkip(firstPixelSkip);
  }
  pictureIsConstructed=true;
}
