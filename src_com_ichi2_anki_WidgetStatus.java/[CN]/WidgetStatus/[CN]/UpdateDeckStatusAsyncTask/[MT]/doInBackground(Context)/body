{
  Context context=params[0];
  if (!AnkiDroidApp.isSdCardMounted()) {
    return context;
  }
  SharedPreferences preferences=PrefSettings.getSharedPrefs(context);
  String deckPath=preferences.getString("deckPath",AnkiDroidApp.getStorageDirectory() + "/AnkiDroid");
  File dir=new File(deckPath);
  File[] fileList=dir.listFiles(new AnkiFileFilter());
  if (fileList == null || fileList.length == 0) {
    mDecks=EMPTY_DECK_STATUS;
    return context;
  }
  ArrayList<DeckStatus> decks=new ArrayList<DeckStatus>(fileList.length);
  for (  File file : fileList) {
    String absPath=null;
    try {
      absPath=file.getAbsolutePath();
      String deckName=file.getName().replaceAll(".anki","");
      Deck deck;
      Deck currentDeck=AnkiDroidApp.deck();
      if (currentDeck != null && currentDeck.getDeckPath().equals(absPath)) {
        deck=currentDeck;
      }
 else {
        try {
          deck=Deck.openDeck(absPath,false);
        }
 catch (        RuntimeException e) {
          Log.w(AnkiDroidApp.TAG,"Widget: Could not open database " + absPath + ": "+ e);
          BackupManager.restoreDeckIfMissing(absPath);
          deck=null;
        }
      }
      if (deck == null) {
        Log.e(AnkiDroidApp.TAG,"Widget: Skipping null deck: " + absPath);
        continue;
      }
      int dueCards=0;
      int newCards=0;
      int failedCards=deck.getFailedSoonCount();
      int eta=0;
      int reps=deck.getSessionFinishedCards();
      if (!deck.hasFinishScheduler()) {
        dueCards=deck.getRevCount();
        newCards=deck.getNewCountToday();
        eta=deck.getETA();
      }
      if (currentDeck != null && currentDeck.getDB() != deck.getDB()) {
        deck.closeDeck();
      }
      decks.add(new DeckStatus(absPath,deckName,newCards,dueCards,failedCards,eta,reps));
    }
 catch (    SQLException e) {
      Log.e(AnkiDroidApp.TAG,e.toString());
      if (absPath != null) {
        BackupManager.restoreDeckIfMissing(absPath);
      }
    }
  }
  if (!decks.isEmpty() && decks.size() > 1) {
    Collections.sort(decks,new ByDueComparator());
  }
  mDecks=decks.toArray(EMPTY_DECK_STATUS);
  return context;
}
