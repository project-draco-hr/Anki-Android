{
  Sched sched=params[0].getSched();
  Collection col=sched.getCol();
  Card card=params[0].getCard();
  Note note=card.note();
  int type=params[0].getInt();
  try {
    col.getDb().getDatabase().beginTransaction();
    try {
switch (type) {
case 4:
        col.markUndo(Collection.UNDO_BURY_CARD,new Object[]{col.getDirty(),note.cards(),card.getId()});
      sched.buryCards(new long[]{card.getId()});
    sHadCardQueue=true;
  break;
case 0:
col.markUndo(Collection.UNDO_BURY_NOTE,new Object[]{col.getDirty(),note.cards(),card.getId()});
sched.buryNote(note.getId());
sHadCardQueue=true;
break;
case 1:
col.markUndo(Collection.UNDO_SUSPEND_CARD,new Object[]{card});
if (card.getQueue() == -1) {
sched.unsuspendCards(new long[]{card.getId()});
}
 else {
sched.suspendCards(new long[]{card.getId()});
}
sHadCardQueue=true;
break;
case 2:
ArrayList<Card> cards=note.cards();
long[] cids=new long[cards.size()];
for (int i=0; i < cards.size(); i++) {
cids[i]=cards.get(i).getId();
}
col.markUndo(Collection.UNDO_SUSPEND_NOTE,new Object[]{cards,card.getId()});
sched.suspendCards(cids);
sHadCardQueue=true;
break;
case 3:
ArrayList<Card> allCs=note.cards();
long[] cardIds=new long[allCs.size()];
for (int i=0; i < allCs.size(); i++) {
cardIds[i]=allCs.get(i).getId();
}
col.markUndo(Collection.UNDO_DELETE_NOTE,new Object[]{note,allCs,card.getId()});
col.remNotes(new long[]{note.getId()});
sHadCardQueue=true;
break;
}
publishProgress(new TaskData(getCard(col.getSched()),0));
col.getDb().getDatabase().setTransactionSuccessful();
}
  finally {
col.getDb().getDatabase().endTransaction();
}
}
 catch (RuntimeException e) {
Timber.e(e,"doInBackgroundSuspendCard - RuntimeException on suspending card");
AnkiDroidApp.sendExceptionReport(e,"doInBackgroundSuspendCard");
return new TaskData(false);
}
return new TaskData(true);
}
