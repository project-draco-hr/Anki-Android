{
  paint.setAntiAlias(mRenderer.isAntialiasing());
  int legendSize=getLegendSize(mRenderer,height / 5,mRenderer.getAxisTitleTextSize());
  int[] margins=mRenderer.getMargins();
  int left=x + margins[1];
  int top=y + margins[0];
  int right=x + width - margins[3];
  int sLength=mDataset.getSeriesCount();
  String[] titles=new String[sLength];
  for (int i=0; i < sLength; i++) {
    titles[i]=mDataset.getSeriesAt(i).getTitle();
  }
  if (mRenderer.isFitLegend() && mRenderer.isShowLegend()) {
    legendSize=drawLegend(canvas,mRenderer,titles,left,right,y,width,height,legendSize,paint,true);
  }
  int bottom=y + height - margins[2] - legendSize;
  if (mScreenR == null) {
    mScreenR=new Rect();
  }
  mScreenR.set(left,top,right,bottom);
  drawBackground(mRenderer,canvas,x,y,width,height,paint,false,DefaultRenderer.NO_COLOR);
  if (paint.getTypeface() == null || !paint.getTypeface().toString().equals(mRenderer.getTextTypefaceName()) || paint.getTypeface().getStyle() != mRenderer.getTextTypefaceStyle()) {
    paint.setTypeface(Typeface.create(mRenderer.getTextTypefaceName(),mRenderer.getTextTypefaceStyle()));
  }
  Orientation or=mRenderer.getOrientation();
  if (or == Orientation.VERTICAL) {
    right-=legendSize;
    bottom+=legendSize - 20;
  }
  int angle=or.getAngle();
  boolean rotate=angle == 90;
  mScale=(float)(height) / width;
  mTranslate=Math.abs(width - height) / 2;
  if (mScale < 1) {
    mTranslate*=-1;
  }
  mCenter=new Point((x + width) / 2,(y + height) / 2);
  if (rotate) {
    transform(canvas,angle,false);
  }
  int maxScaleNumber=-Integer.MAX_VALUE;
  for (int i=0; i < sLength; i++) {
    maxScaleNumber=Math.max(maxScaleNumber,mDataset.getSeriesAt(i).getScaleNumber());
  }
  maxScaleNumber++;
  if (maxScaleNumber < 0) {
    return;
  }
  double[] minX=new double[maxScaleNumber];
  double[] maxX=new double[maxScaleNumber];
  double[] minY=new double[maxScaleNumber];
  double[] maxY=new double[maxScaleNumber];
  boolean[] isMinXSet=new boolean[maxScaleNumber];
  boolean[] isMaxXSet=new boolean[maxScaleNumber];
  boolean[] isMinYSet=new boolean[maxScaleNumber];
  boolean[] isMaxYSet=new boolean[maxScaleNumber];
  for (int i=0; i < maxScaleNumber; i++) {
    minX[i]=mRenderer.getXAxisMin(i);
    maxX[i]=mRenderer.getXAxisMax(i);
    minY[i]=mRenderer.getYAxisMin(i);
    maxY[i]=mRenderer.getYAxisMax(i);
    isMinXSet[i]=mRenderer.isMinXSet(i);
    isMaxXSet[i]=mRenderer.isMaxXSet(i);
    isMinYSet[i]=mRenderer.isMinYSet(i);
    isMaxYSet[i]=mRenderer.isMaxYSet(i);
    if (mCalcRange.get(i) == null) {
      mCalcRange.put(i,new double[4]);
    }
  }
  double[] xPixelsPerUnit=new double[maxScaleNumber];
  double[] yPixelsPerUnit=new double[maxScaleNumber];
  for (int i=0; i < sLength; i++) {
    XYSeries series=mDataset.getSeriesAt(i);
    int scale=series.getScaleNumber();
    if (series.getItemCount() == 0) {
      continue;
    }
    if (!isMinXSet[scale]) {
      double minimumX=series.getMinX();
      minX[scale]=Math.min(minX[scale],minimumX);
      mCalcRange.get(scale)[0]=minX[scale];
    }
    if (!isMaxXSet[scale]) {
      double maximumX=series.getMaxX();
      maxX[scale]=Math.max(maxX[scale],maximumX);
      mCalcRange.get(scale)[1]=maxX[scale];
    }
    if (!isMinYSet[scale]) {
      double minimumY=series.getMinY();
      minY[scale]=Math.min(minY[scale],(float)minimumY);
      mCalcRange.get(scale)[2]=minY[scale];
    }
    if (!isMaxYSet[scale]) {
      double maximumY=series.getMaxY();
      maxY[scale]=Math.max(maxY[scale],(float)maximumY);
      mCalcRange.get(scale)[3]=maxY[scale];
    }
  }
  for (int i=0; i < maxScaleNumber; i++) {
    if (maxX[i] - minX[i] != 0) {
      xPixelsPerUnit[i]=(right - left) / (maxX[i] - minX[i]);
    }
    if (maxY[i] - minY[i] != 0) {
      yPixelsPerUnit[i]=(float)((bottom - top) / (maxY[i] - minY[i]));
    }
  }
  boolean hasValues=false;
  clickableAreas=new HashMap<Integer,List<ClickableArea>>();
  for (int i=0; i < sLength; i++) {
    XYSeries series=mDataset.getSeriesAt(i);
    int scale=series.getScaleNumber();
    if (series.getItemCount() == 0) {
      continue;
    }
    hasValues=true;
    SimpleSeriesRenderer seriesRenderer=mRenderer.getSeriesRendererAt(i);
    List<Float> points=new ArrayList<Float>();
    List<Double> values=new ArrayList<Double>();
    float yAxisValue=Math.min(bottom,(float)(bottom + yPixelsPerUnit[scale] * minY[scale]));
    LinkedList<ClickableArea> clickableArea=new LinkedList<ClickableArea>();
    clickableAreas.put(i,clickableArea);
    SortedMap<Double,Double> range=series.getRange(minX[scale],maxX[scale],1);
    int startIndex=-1;
    int intRange=range.lastKey().intValue() - range.firstKey().intValue();
    for (    Entry<Double,Double> value : range.entrySet()) {
      double xValue=value.getKey();
      double yValue=value.getValue();
      if (startIndex < 0) {
        startIndex=series.getIndexForKey(xValue);
      }
      values.add(value.getKey());
      values.add(value.getValue());
      if (!isNullValue(yValue)) {
        points.add((float)(left + xPixelsPerUnit[scale] * (xValue - minX[scale])));
        points.add((float)(bottom - yPixelsPerUnit[scale] * (yValue - minY[scale])));
      }
 else       if (isRenderNullValues()) {
        points.add((float)(left + xPixelsPerUnit[scale] * (xValue - minX[scale])));
        points.add((float)(bottom - yPixelsPerUnit[scale] * (-minY[scale])));
      }
 else {
        if (points.size() > 0) {
          drawSeries(series,canvas,paint,points,seriesRenderer,yAxisValue,i,or,startIndex,intRange);
          ClickableArea[] clickableAreasForSubSeries=clickableAreasForPoints(MathHelper.getFloats(points),MathHelper.getDoubles(values),yAxisValue,i,startIndex,intRange);
          clickableArea.addAll(Arrays.asList(clickableAreasForSubSeries));
          points.clear();
          values.clear();
        }
        clickableArea.add(null);
      }
    }
    if (points.size() > 0) {
      drawSeries(series,canvas,paint,points,seriesRenderer,yAxisValue,i,or,startIndex,intRange);
      ClickableArea[] clickableAreasForSubSeries=clickableAreasForPoints(MathHelper.getFloats(points),MathHelper.getDoubles(values),yAxisValue,i,startIndex,intRange);
      clickableArea.addAll(Arrays.asList(clickableAreasForSubSeries));
    }
  }
  drawBackground(mRenderer,canvas,x,bottom,width,height - bottom,paint,true,mRenderer.getMarginsColor());
  drawBackground(mRenderer,canvas,x,y,width,margins[0],paint,true,mRenderer.getMarginsColor());
  if (or == Orientation.HORIZONTAL) {
    drawBackground(mRenderer,canvas,x,y,left - x,height - y,paint,true,mRenderer.getMarginsColor());
    drawBackground(mRenderer,canvas,right,y,margins[3],height - y,paint,true,mRenderer.getMarginsColor());
  }
 else   if (or == Orientation.VERTICAL) {
    drawBackground(mRenderer,canvas,right,y,width - right,height - y,paint,true,mRenderer.getMarginsColor());
    drawBackground(mRenderer,canvas,x,y,left - x,height - y,paint,true,mRenderer.getMarginsColor());
  }
  boolean showLabels=mRenderer.isShowLabels() && hasValues;
  boolean showGridX=mRenderer.isShowGridX();
  boolean showCustomTextGrid=mRenderer.isShowCustomTextGrid();
  if (showLabels || showGridX) {
    List<Double> xLabels=getValidLabels(getXLabels(minX[0],maxX[0],mRenderer.getXLabels()));
    Map<Integer,List<Double>> allYLabels=getYLabels(minY,maxY,maxScaleNumber);
    int xLabelsLeft=left;
    if (showLabels) {
      paint.setColor(mRenderer.getXLabelsColor());
      paint.setTextSize(mRenderer.getLabelsTextSize());
      paint.setTextAlign(mRenderer.getXLabelsAlign());
      if (mRenderer.getXLabelsAlign() == Align.LEFT) {
        xLabelsLeft+=mRenderer.getLabelsTextSize() / 4;
      }
    }
    drawXLabels(xLabels,mRenderer.getXTextLabelLocations(),canvas,paint,xLabelsLeft,top,bottom,xPixelsPerUnit[0],minX[0],maxX[0]);
    drawYLabels(allYLabels,canvas,paint,maxScaleNumber,left,right,bottom,yPixelsPerUnit,minY);
    if (showLabels) {
      paint.setColor(mRenderer.getLabelsColor());
      for (int i=0; i < maxScaleNumber; i++) {
        Align axisAlign=mRenderer.getYAxisAlign(i);
        Double[] yTextLabelLocations=mRenderer.getYTextLabelLocations(i);
        for (        Double location : yTextLabelLocations) {
          if (minY[i] <= location && location <= maxY[i]) {
            float yLabel=(float)(bottom - yPixelsPerUnit[i] * (location.doubleValue() - minY[i]));
            String label=mRenderer.getYTextLabel(location,i);
            paint.setColor(mRenderer.getYLabelsColor(i));
            paint.setTextAlign(mRenderer.getYLabelsAlign(i));
            if (or == Orientation.HORIZONTAL) {
              if (axisAlign == Align.LEFT) {
                canvas.drawLine(left + getLabelLinePos(axisAlign),yLabel,left,yLabel,paint);
                drawText(canvas,label,left,yLabel - 2,paint,mRenderer.getYLabelsAngle());
              }
 else {
                canvas.drawLine(right,yLabel,right + getLabelLinePos(axisAlign),yLabel,paint);
                drawText(canvas,label,right,yLabel - 2,paint,mRenderer.getYLabelsAngle());
              }
              if (showCustomTextGrid) {
                paint.setColor(mRenderer.getGridColor());
                canvas.drawLine(left,yLabel,right,yLabel,paint);
              }
            }
 else {
              canvas.drawLine(right - getLabelLinePos(axisAlign),yLabel,right,yLabel,paint);
              drawText(canvas,label,right + 10,yLabel - 2,paint,mRenderer.getYLabelsAngle());
              if (showCustomTextGrid) {
                paint.setColor(mRenderer.getGridColor());
                canvas.drawLine(right,yLabel,left,yLabel,paint);
              }
            }
          }
        }
      }
    }
    if (showLabels) {
      paint.setColor(mRenderer.getLabelsColor());
      float size=mRenderer.getAxisTitleTextSize();
      paint.setTextSize(size);
      paint.setTextAlign(Align.CENTER);
      if (or == Orientation.HORIZONTAL) {
        drawText(canvas,mRenderer.getXTitle(),x + width / 2,bottom + mRenderer.getLabelsTextSize() * 4 / 3 + size,paint,0);
        for (int i=0; i < maxScaleNumber; i++) {
          Align axisAlign=mRenderer.getYAxisAlign(i);
          if (axisAlign == Align.LEFT) {
            drawText(canvas,mRenderer.getYTitle(i),x + size,y + height / 2,paint,-90);
          }
 else {
            drawText(canvas,mRenderer.getYTitle(i),x + width,y + height / 2,paint,-90);
          }
        }
        paint.setTextSize(mRenderer.getChartTitleTextSize());
        drawText(canvas,mRenderer.getChartTitle(),x + width / 2,y + mRenderer.getChartTitleTextSize(),paint,0);
      }
 else       if (or == Orientation.VERTICAL) {
        drawText(canvas,mRenderer.getXTitle(),x + width / 2,y + height - size,paint,-90);
        drawText(canvas,mRenderer.getYTitle(),right + 20,y + height / 2,paint,0);
        paint.setTextSize(mRenderer.getChartTitleTextSize());
        drawText(canvas,mRenderer.getChartTitle(),x + size,top + height / 2,paint,0);
      }
    }
  }
  if (or == Orientation.HORIZONTAL) {
    drawLegend(canvas,mRenderer,titles,left,right,y,width,height,legendSize,paint,false);
  }
 else   if (or == Orientation.VERTICAL) {
    transform(canvas,angle,true);
    drawLegend(canvas,mRenderer,titles,left,right,y,width,height,legendSize,paint,false);
    transform(canvas,angle,false);
  }
  if (mRenderer.isShowAxes()) {
    paint.setColor(mRenderer.getAxesColor());
    canvas.drawLine(left,bottom,right,bottom,paint);
    boolean rightAxis=false;
    for (int i=0; i < maxScaleNumber && !rightAxis; i++) {
      rightAxis=mRenderer.getYAxisAlign(i) == Align.RIGHT;
    }
    if (or == Orientation.HORIZONTAL) {
      canvas.drawLine(left,top,left,bottom,paint);
      if (rightAxis) {
        canvas.drawLine(right,top,right,bottom,paint);
      }
    }
 else     if (or == Orientation.VERTICAL) {
      canvas.drawLine(right,top,right,bottom,paint);
    }
  }
  if (rotate) {
    transform(canvas,angle,true);
  }
}
