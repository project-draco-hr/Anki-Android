{
  DeckTask.launchDeckTask(DeckTask.TASK_TYPE_LOAD_DECK_COUNTS,new DeckTask.TaskListener(){
    @Override public void onPreExecute(){
      Timber.d("Refreshing deck list");
    }
    @Override public void onPostExecute(    TaskData result){
      if (result == null) {
        Timber.e("null result loading deck counts");
        onCollectionLoadError();
        return;
      }
      List<Sched.DeckDueTreeNode> nodes=(List<Sched.DeckDueTreeNode>)result.getObjArray()[0];
      mDeckListAdapter.buildDeckList(nodes);
      try {
        int eta=mDeckListAdapter.getEta();
        int due=mDeckListAdapter.getDue();
        Resources res=getResources();
        if (getCol().cardCount() != -1) {
          String time="-";
          if (eta != -1) {
            time=res.getQuantityString(R.plurals.deckpicker_title_minutes,eta,eta);
          }
          getSupportActionBar().setSubtitle(res.getQuantityString(R.plurals.deckpicker_title,due,due,time));
        }
      }
 catch (      RuntimeException e) {
        Timber.e(e,"RuntimeException setting time remaining");
        onCollectionLoadError();
        return;
      }
      long current=getCol().getDecks().current().optLong("id");
      if (mFocusedDeck != current) {
        scrollDecklistToDeck(current);
        mFocusedDeck=current;
      }
      WidgetStatus.update(DeckPicker.this,nodes);
      supportInvalidateOptionsMenu();
      AnkiStatsTaskHandler.createSmallTodayOverview(getCol(),mTodayTextView);
    }
    @Override public void onProgressUpdate(    TaskData... values){
    }
    @Override public void onCancelled(){
    }
  }
,new TaskData(getCol()));
}
