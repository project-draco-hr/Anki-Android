{
  InputStream cont;
  try {
    HttpResponse ret=super.req("download");
    if (ret == null) {
      return null;
    }
    cont=ret.getEntity().getContent();
  }
 catch (  IllegalStateException e1) {
    throw new RuntimeException(e1);
  }
catch (  IOException e1) {
    return null;
  }
  String path;
  if (mCol != null) {
    path=mCol.getPath();
    mCol.close(false);
    mCol=null;
  }
 else {
    Timber.w("Collection was unexpectedly null when doing full sync download");
    path=CollectionHelper.getCollectionPath(AnkiDroidApp.getInstance());
  }
  String tpath=path + ".tmp";
  try {
    super.writeToFile(cont,tpath);
  }
 catch (  IOException e) {
    Timber.e(e,"Full sync failed to download collection.");
    return new Object[]{"sdAccessError"};
  }
  try {
    FileInputStream fis=new FileInputStream(tpath);
    if (super.stream2String(fis,15).equals("upgradeRequired")) {
      return new Object[]{"upgradeRequired"};
    }
  }
 catch (  FileNotFoundException e1) {
    throw new RuntimeException(e1);
  }
  mCon.publishProgress(R.string.sync_check_download_file);
  AnkiDb tempDb=null;
  try {
    tempDb=new AnkiDb(tpath);
    if (!tempDb.queryString("PRAGMA integrity_check").equalsIgnoreCase("ok")) {
      Timber.e("Full sync - downloaded file corrupt");
      return new Object[]{"remoteDbError"};
    }
  }
 catch (  SQLiteDatabaseCorruptException e) {
    Timber.e("Full sync - downloaded file corrupt");
    return new Object[]{"remoteDbError"};
  }
 finally {
    if (tempDb != null) {
      tempDb.closeDatabase();
    }
  }
  File newFile=new File(tpath);
  if (newFile.renameTo(new File(path))) {
    return new Object[]{"success"};
  }
 else {
    return new Object[]{"overwriteError"};
  }
}
