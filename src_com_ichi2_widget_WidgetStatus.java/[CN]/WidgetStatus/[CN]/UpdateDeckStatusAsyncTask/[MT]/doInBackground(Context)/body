{
  Log.d(AnkiDroidApp.TAG,"WidgetStatus.UpdateDeckStatusAsyncTask.doInBackground()");
  Context context=params[0];
  if (!AnkiDroidApp.isSdCardMounted()) {
    return context;
  }
  ArrayList<DeckStatus> decks;
  if (sDeckStatus != null && mDecks != null && mDecks.length > 0) {
    decks=new ArrayList<DeckStatus>(mDecks.length);
    for (    DeckStatus m : mDecks) {
      if (m.mDeckPath.equals(sDeckStatus.mDeckPath)) {
        Log.i(AnkiDroidApp.TAG,"UpdateWidget - update information for deck " + sDeckStatus.mDeckPath);
        decks.add(sDeckStatus);
      }
 else {
        Log.i(AnkiDroidApp.TAG,"UpdateWidget - copy information for deck " + m.mDeckPath);
        decks.add(m);
      }
    }
  }
 else {
    SharedPreferences preferences=PrefSettings.getSharedPrefs(context);
    String deckPath=preferences.getString("deckPath",AnkiDroidApp.getStorageDirectory() + "/AnkiDroid");
    File dir=new File(deckPath);
    File[] fileList=dir.listFiles(new AnkiFileFilter());
    if (fileList == null || fileList.length == 0) {
      mDecks=EMPTY_DECK_STATUS;
      return context;
    }
    decks=new ArrayList<DeckStatus>(fileList.length);
    for (    File file : fileList) {
      String absPath=null;
      try {
        absPath=file.getAbsolutePath();
        String deckName=file.getName().replaceAll(".anki","");
        Log.i(AnkiDroidApp.TAG,"WidgetStatus: Found deck: " + absPath);
        Deck deck=DeckManager.getDeck(absPath,DeckManager.REQUESTING_ACTIVITY_WIDGETSTATUS,false);
        if (deck == null) {
          Log.e(AnkiDroidApp.TAG,"Widget: Skipping null deck: " + absPath);
          continue;
        }
        int dueCards=0;
        int newCards=0;
        int failedCards=deck.getFailedSoonCount();
        int eta=0;
        int reps=deck.getSessionFinishedCards();
        if (!deck.hasFinishScheduler()) {
          dueCards=deck.getRevCount();
          newCards=deck.getNewCountToday();
          eta=deck.getETA();
        }
        DeckManager.closeDeck(absPath,DeckManager.REQUESTING_ACTIVITY_WIDGETSTATUS);
        decks.add(new DeckStatus(absPath,deckName,newCards,dueCards,failedCards,eta,reps));
      }
 catch (      SQLException e) {
        Log.i(AnkiDroidApp.TAG,"Widget: Problems on retrieving deck information");
        Log.e(AnkiDroidApp.TAG,e.toString());
        if (absPath != null) {
          BackupManager.restoreDeckIfMissing(absPath);
        }
      }
    }
  }
  if (!decks.isEmpty() && decks.size() > 1) {
    Log.i(AnkiDroidApp.TAG,"Sorting deck");
    Collections.sort(decks,new ByNameComparator());
  }
  mDecks=decks.toArray(EMPTY_DECK_STATUS);
  return context;
}
