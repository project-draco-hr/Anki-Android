{
  Log.d(AnkiDroidApp.TAG,"WidgetStatus.UpdateDeckStatusAsyncTask.doInBackground()");
  Context context=params[0];
  if (!AnkiDroidApp.isSdCardMounted()) {
    return context;
  }
  ArrayList<DeckStatus> decks=new ArrayList<DeckStatus>();
  try {
    Collection col=Collection.currentCollection();
    Object[] di;
    float progress;
    if (col == null) {
      col=Collection.openCollection(AnkiDroidApp.getCollectionPath());
      di=col.getSched().deckCounts();
      progress=col.getSched().todaysProgress(null,true,true);
      col.close(false);
    }
 else {
      di=col.getSched().deckCounts();
      progress=col.getSched().todaysProgress(null,true,true);
    }
    int eta=(Integer)di[1];
    for (    Object[] d : (TreeSet<Object[]>)di[0]) {
      String[] name=((String[])d[0]);
      int newCount=(Integer)d[2];
      int lrnCount=(Integer)d[3];
      int revCount=(Integer)d[4];
      decks.add(new DeckStatus((Long)d[1],name.length,DeckPicker.readableDeckName(name),newCount,lrnCount,revCount,(int)(progress * 100),eta));
    }
  }
 catch (  SQLException e) {
    Log.i(AnkiDroidApp.TAG,"Widget: Problems on retrieving deck information");
  }
  mDecks=decks.toArray(EMPTY_DECK_STATUS);
  return context;
}
