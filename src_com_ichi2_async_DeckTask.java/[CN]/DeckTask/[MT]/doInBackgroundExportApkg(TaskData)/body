{
  final int BUFFER_SIZE=1024;
  Log.i(AnkiDroidApp.TAG,"doInBackgroundExportApkg");
  Object[] data=params[0].getObjArray();
  String colPath=(String)data[0];
  String apkgPath=(String)data[1];
  boolean includeMedia=(Boolean)data[2];
  byte[] buf=new byte[BUFFER_SIZE];
  try {
    try {
      AnkiDb d=AnkiDatabaseManager.getDatabase(colPath);
    }
 catch (    SQLiteDatabaseCorruptException e) {
      return new TaskData(false);
    }
 finally {
      AnkiDatabaseManager.closeDatabase(colPath);
    }
    ZipOutputStream zos=new ZipOutputStream(new BufferedOutputStream(new FileOutputStream(apkgPath)));
    BufferedInputStream bis=new BufferedInputStream(new FileInputStream(colPath),BUFFER_SIZE);
    ZipEntry ze=new ZipEntry("collection.anki2");
    zos.putNextEntry(ze);
    int len;
    while ((len=bis.read(buf,0,BUFFER_SIZE)) != -1) {
      zos.write(buf,0,len);
    }
    zos.closeEntry();
    bis.close();
    JSONObject media=new JSONObject();
    if (includeMedia) {
      File mediaDir=new File(AnkiDroidApp.getCol().getMedia().dir());
      if (mediaDir.exists() && mediaDir.isDirectory()) {
        File[] mediaFiles=mediaDir.listFiles();
        int c=0;
        for (        File f : mediaFiles) {
          FileInputStream mediaFin=new FileInputStream(f);
          ze=new ZipEntry(Integer.toString(c));
          zos.putNextEntry(ze);
          while ((len=mediaFin.read(buf)) >= 0) {
            zos.write(buf,0,len);
          }
          zos.closeEntry();
          mediaFin.close();
          media.put(Integer.toString(c),f.getName());
        }
      }
    }
    ze=new ZipEntry("media");
    zos.putNextEntry(ze);
    InputStream mediaIn=new ByteArrayInputStream(Utils.jsonToString(media).getBytes("UTF-8"));
    while ((len=mediaIn.read(buf)) >= 0) {
      zos.write(buf,0,len);
    }
    zos.closeEntry();
    zos.close();
  }
 catch (  FileNotFoundException e) {
    return new TaskData(false);
  }
catch (  IOException e) {
    return new TaskData(false);
  }
catch (  JSONException e) {
    return new TaskData(false);
  }
  return new TaskData(true);
}
