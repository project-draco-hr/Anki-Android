{
  Sched sched=params[0].getSched();
  Collection col=sched.getCol();
  Card card=params[0].getCard();
  Note note=card.note();
  int type=params[0].getInt();
  try {
    col.getDb().getDatabase().beginTransaction();
    try {
switch (type) {
case 0:
        long[] cardIds=Utils.arrayList2array(col.getDb().queryColumn(Long.class,"SELECT id FROM cards WHERE nid = " + note.getId(),0));
      ArrayList<Card> undoCards=new ArrayList<Card>();
    for (    long c : cardIds) {
      undoCards.add(col.getCard(c));
    }
  col.markUndo(Collection.UNDO_BURY_NOTE,new Object[]{col.getDirty(),undoCards,card.getId()});
sched.buryNote(note.getId());
break;
case 1:
if (card.getQueue() == -1) {
sched.unsuspendCards(new long[]{card.getId()});
}
 else {
sched.suspendCards(new long[]{card.getId()});
}
break;
case 2:
ArrayList<Card> cards=note.cards();
long[] cids=new long[cards.size()];
for (int i=0; i < cards.size(); i++) {
cids[i]=cards.get(i).getId();
}
sched.suspendCards(cids);
break;
case 3:
col.remNotes(new long[]{note.getId()});
break;
}
publishProgress(new TaskData(getCard(col.getSched()),0));
col.getDb().getDatabase().setTransactionSuccessful();
}
  finally {
col.getDb().getDatabase().endTransaction();
}
}
 catch (RuntimeException e) {
Log.e(AnkiDroidApp.TAG,"doInBackgroundSuspendCard - RuntimeException on suspending card: " + e);
AnkiDroidApp.saveExceptionReportFile(e,"doInBackgroundSuspendCard");
return new TaskData(false);
}
return new TaskData(true);
}
