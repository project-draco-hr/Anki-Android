{
  Object[] data=mUndo.removeLast();
switch ((Integer)data[0]) {
case UNDO_REVIEW:
    Card c=(Card)data[1];
  c.flush(false);
long last=mDb.queryLongScalar("SELECT id FROM revlog WHERE cid = " + c.getId() + " ORDER BY id DESC LIMIT 1");
mDb.execute("DELETE FROM revlog WHERE id = " + last);
int n=c.getQueue() == 3 ? 1 : c.getQueue();
String type=(new String[]{"new","lrn","rev"})[n];
mSched._updateStats(c,type,-1);
return c.getId();
case UNDO_EDIT_NOTE:
Note note=(Note)data[1];
note.flush(note.getMod(),false);
long cid=(Long)data[2];
Card card=null;
if ((Boolean)data[3]) {
Card newCard=getCard(cid);
if (getDecks().active().contains(newCard.getDid())) {
card=newCard;
card.load();
card.getQuestion(true);
}
}
if (card == null) {
card=getSched().getCard();
}
if (card != null) {
return card.getId();
}
return 0;
case UNDO_BURY_NOTE:
setDirty((Boolean)data[1]);
for (Card cc : (ArrayList<Card>)data[2]) {
cc.flush(false);
}
return (Long)data[3];
case UNDO_SUSPEND_CARD:
Card suspendedCard=(Card)data[1];
suspendedCard.flush(false);
return suspendedCard.getId();
case UNDO_SUSPEND_NOTE:
for (Card ccc : (ArrayList<Card>)data[1]) {
ccc.flush(false);
}
return (Long)data[2];
case UNDO_DELETE_NOTE:
ArrayList<Long> ids=new ArrayList<Long>();
Note note2=(Note)data[1];
note2.flush(note2.getMod(),false);
ids.add(note2.getId());
for (Card c4 : (ArrayList<Card>)data[2]) {
c4.flush(false);
ids.add(c4.getId());
}
mDb.execute("DELETE FROM graves WHERE oid IN " + Utils.ids2str(Utils.arrayList2array(ids)));
mDb.executeMany("INSERT INTO revlog VALUES (?,?,?,?,?,?,?,?,?)",(ArrayList<Object[]>)data[4]);
return (Long)data[3];
case UNDO_MARK_NOTE:
Note note3=getNote((Long)data[1]);
note3.setTagsFromStr((String)data[2]);
note3.flush(note3.getMod(),false);
return (Long)data[3];
default :
return 0;
}
}
