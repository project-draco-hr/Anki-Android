{
  Object[] data=mUndo.removeLast();
switch ((Integer)data[0]) {
case UNDO_REVIEW:
    Card c=(Card)data[1];
  Boolean wasLeech=(Boolean)data[2];
if (!wasLeech && c.note().hasTag("leech")) {
  c.note().delTag("leech");
  c.note().flush();
}
c.flush(false);
long last=mDb.queryLongScalar("SELECT id FROM revlog WHERE cid = " + c.getId() + " ORDER BY id DESC LIMIT 1");
mDb.execute("DELETE FROM revlog WHERE id = " + last);
mDb.execute("update cards set queue=type,mod=?,usn=? where queue=-2 and nid=?",new Object[]{Utils.intNow(),usn(),c.getNid()});
int n=c.getQueue() == 3 ? 1 : c.getQueue();
String type=(new String[]{"new","lrn","rev"})[n];
mSched._updateStats(c,type,-1);
mSched.setReps(mSched.getReps() - 1);
return c.getId();
case UNDO_EDIT_NOTE:
Note note=(Note)data[1];
note.flush(note.getMod(),false);
long cid=(Long)data[2];
Card card=null;
if ((Boolean)data[3]) {
Card newCard=getCard(cid);
if (getDecks().active().contains(newCard.getDid())) {
card=newCard;
card.load();
card.q(true,true);
}
}
if (card == null) {
card=getSched().getCard();
}
if (card != null) {
return card.getId();
}
return 0;
case UNDO_BURY_NOTE:
for (Card cc : (ArrayList<Card>)data[2]) {
cc.flush(false);
}
return (Long)data[3];
case UNDO_SUSPEND_CARD:
Card suspendedCard=(Card)data[1];
suspendedCard.flush(false);
return suspendedCard.getId();
case UNDO_SUSPEND_NOTE:
for (Card ccc : (ArrayList<Card>)data[1]) {
ccc.flush(false);
}
return (Long)data[2];
case UNDO_DELETE_NOTE:
ArrayList<Long> ids=new ArrayList<Long>();
Note note2=(Note)data[1];
note2.flush(note2.getMod(),false);
ids.add(note2.getId());
for (Card c4 : (ArrayList<Card>)data[2]) {
c4.flush(false);
ids.add(c4.getId());
}
mDb.execute("DELETE FROM graves WHERE oid IN " + Utils.ids2str(Utils.arrayList2array(ids)));
return (Long)data[3];
case UNDO_MARK_NOTE:
Note note3=getNote((Long)data[1]);
note3.setTagsFromStr((String)data[2]);
note3.flush(note3.getMod(),false);
return (Long)data[3];
default :
return 0;
}
}
