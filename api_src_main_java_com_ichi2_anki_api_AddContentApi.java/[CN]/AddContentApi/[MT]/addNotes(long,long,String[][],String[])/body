{
  if (tagsArr != null && fieldsArr.length != tagsArr.length) {
    throw new IllegalArgumentException("fieldsArr and tagsArr different length");
  }
  NoteInfo[] existingNotes=getCompat().findExistingNotes(mid,fieldsArr);
  List<ContentValues> newNoteValuesList=new ArrayList<>();
  NoteInfo[] result=new NoteInfo[fieldsArr.length];
  Map<String,Integer> resultsMap=new HashMap<>();
  for (int i=0; i < fieldsArr.length; i++) {
    String[] fields=fieldsArr[i];
    if (fields == null || resultsMap.containsKey(fields[0]) || (existingNotes != null && existingNotes[i] != null)) {
      if (existingNotes != null && existingNotes[i] != null) {
        result[i]=existingNotes[i];
        result[i].newlyAdded=false;
      }
      continue;
    }
    ContentValues values=new ContentValues();
    values.put(FlashCardsContract.Note.MID,mid);
    values.put(FlashCardsContract.Note.FLDS,Utils.joinFields(fields));
    if (tagsArr != null && tagsArr[i] != null) {
      values.put(FlashCardsContract.Note.TAGS,tagsArr[i]);
    }
    newNoteValuesList.add(values);
    resultsMap.put(fields[0],i);
  }
  if (!newNoteValuesList.isEmpty()) {
    getCompat().addNewNotes(did,newNoteValuesList.toArray(new ContentValues[newNoteValuesList.size()]));
    NoteInfo[] newNotes=getCompat().findExistingNotes(mid,fieldsArr);
    for (    String key : resultsMap.keySet()) {
      int originalIndex=resultsMap.get(key);
      result[originalIndex]=newNotes[originalIndex];
      result[originalIndex].newlyAdded=true;
    }
  }
  return result;
}
