{
  if (order == null || order.length() == 0) {
    return new Pair<String,Boolean>("",false);
  }
 else   if (!order.equalsIgnoreCase("true")) {
    return new Pair<String,Boolean>(" order by " + order,false);
  }
  String type;
  try {
    type=mCol.getConf().getString("sortType");
    String sort=null;
    if (type.startsWith("note")) {
      if (type.startsWith("noteCrt")) {
        sort="n.id, c.ord";
      }
 else       if (type.startsWith("noteMod")) {
        sort="n.mod, c.ord";
      }
 else       if (type.startsWith("noteFld")) {
        sort="n.sfld COLLATE NOCASE, c.ord";
      }
    }
 else     if (type.startsWith("card")) {
      if (type.startsWith("cardMod")) {
        sort="c.mod";
      }
 else       if (type.startsWith("cardReps")) {
        sort="c.reps";
      }
 else       if (type.startsWith("cardDue")) {
        sort="c.type, c.due";
      }
 else       if (type.startsWith("cardEase")) {
        sort="c.factor";
      }
 else       if (type.startsWith("cardLapses")) {
        sort="c.lapses";
      }
 else       if (type.startsWith("cardIvl")) {
        sort="c.ivl";
      }
    }
    if (sort == null) {
      sort="n.id, c.ord";
    }
    boolean sortBackwards=Upgrade.upgradeJSONIfNecessary(mCol,mCol.getConf(),"sortBackwards",false);
    return new Pair<String,Boolean>(" ORDER BY " + sort,sortBackwards);
  }
 catch (  JSONException e) {
    throw new RuntimeException(e);
  }
}
