{
  Log.d(AnkiDroidApp.TAG,"DeckOptions - commit() changes back to database");
  try {
    for (    Entry<String,Object> entry : mUpdate.valueSet()) {
      String key=entry.getKey();
      Log.i(AnkiDroidApp.TAG,"Change value for key '" + key + "': "+ entry.getValue());
      if (mNumericOptions.containsKey(key)) {
        int value=getValidatedNumericInput(key,entry.getValue());
        if (key.equals("maxAnswerTime")) {
          mOptions.put("maxTaken",value);
        }
 else         if (key.equals("newFactor")) {
          mOptions.getJSONObject("new").put("initialFactor",value * 10);
        }
 else         if (key.equals("newOrder")) {
          int oldValue=mOptions.getJSONObject("new").getInt("order");
          if (oldValue != value) {
            mOptions.getJSONObject("new").put("order",value);
            DeckTask.launchDeckTask(DeckTask.TASK_TYPE_REORDER,mReorderHandler,new DeckTask.TaskData(new Object[]{mCol,mOptions}));
          }
          mOptions.getJSONObject("new").put("order",value);
        }
 else         if (key.equals("newPerDay")) {
          mOptions.getJSONObject("new").put("perDay",value);
        }
 else         if (key.equals("newGradIvl")) {
          JSONArray ja=new JSONArray();
          ja.put(value);
          ja.put(mOptions.getJSONObject("new").getJSONArray("ints").get(1));
          mOptions.getJSONObject("new").put("ints",ja);
        }
 else         if (key.equals("newEasy")) {
          JSONArray ja=new JSONArray();
          ja.put(mOptions.getJSONObject("new").getJSONArray("ints").get(0));
          ja.put(value);
          mOptions.getJSONObject("new").put("ints",ja);
        }
 else         if (key.equals("revPerDay")) {
          mOptions.getJSONObject("rev").put("perDay",value);
        }
 else         if (key.equals("revSpaceMax")) {
          mOptions.getJSONObject("rev").put("fuzz",value / 100.0f);
        }
 else         if (key.equals("revSpaceMin")) {
          mOptions.getJSONObject("rev").put("minSpace",value);
        }
 else         if (key.equals("easyBonus")) {
          mOptions.getJSONObject("rev").put("ease4",value / 100.0f);
        }
 else         if (key.equals("revIvlFct")) {
          mOptions.getJSONObject("rev").put("ivlFct",value / 100.0f);
        }
 else         if (key.equals("revMaxIvl")) {
          mOptions.getJSONObject("rev").put("maxIvl",value);
        }
 else         if (key.equals("lapMinIvl")) {
          mOptions.getJSONObject("lapse").put("minInt",value);
        }
 else         if (key.equals("lapLeechThres")) {
          mOptions.getJSONObject("lapse").put("leechFails",value);
        }
 else         if (key.equals("lapLeechAct")) {
          mOptions.getJSONObject("lapse").put("leechAction",value);
        }
 else         if (key.equals("lapNewIvl")) {
          mOptions.getJSONObject("lapse").put("mult",value / 100.0f);
        }
      }
 else       if (mBoolOptions.contains(key)) {
        boolean enabled=(Boolean)entry.getValue();
        if (key.equals("showAnswerTimer")) {
          mOptions.put("timer",enabled ? 1 : 0);
        }
 else         if (key.equals("autoPlayAudio")) {
          mOptions.put("autoplay",enabled);
        }
 else         if (key.equals("replayQuestion")) {
          mOptions.put("replayq",enabled);
        }
 else         if (key.equals("newSeparate")) {
          mOptions.getJSONObject("new").put("separate",enabled);
        }
      }
 else {
        String value=(String)entry.getValue();
        if (key.equals("name")) {
          if (!mCol.getDecks().rename(mDeck,value)) {
            Themes.showThemedToast(DeckOptions.this,getResources().getString(R.string.rename_error,mDeck.get("name")),false);
          }
        }
 else         if (key.equals("desc")) {
          mDeck.put("desc",value);
          mCol.getDecks().save(mDeck);
        }
 else         if (key.equals("deckConf")) {
          mCol.getDecks().setConf(mDeck,Long.parseLong(value));
          mOptions=mCol.getDecks().confForDid(mDeck.getLong("id"));
        }
 else         if (key.equals("newSteps")) {
          JSONArray steps=getValidatedStepsInput(value);
          if (steps == null) {
            Themes.showThemedToast(DeckOptions.this,getResources().getString(R.string.steps_error),false);
          }
 else           if (steps.length() == 0) {
            Themes.showThemedToast(DeckOptions.this,getResources().getString(R.string.steps_min_error),false);
          }
 else {
            mOptions.getJSONObject("new").put("delays",steps);
          }
        }
 else         if (key.equals("lapSteps")) {
          JSONArray steps=getValidatedStepsInput(value);
          if (steps != null) {
            mOptions.getJSONObject("lapse").put("delays",steps);
          }
 else {
            Themes.showThemedToast(DeckOptions.this,getResources().getString(R.string.steps_error),false);
          }
        }
      }
    }
  }
 catch (  JSONException e) {
    throw new RuntimeException(e);
  }
  try {
    mCol.getDecks().save(mOptions);
  }
 catch (  RuntimeException e) {
    Log.e(AnkiDroidApp.TAG,"DeckOptions - RuntimeException on saving conf: " + e);
    AnkiDroidApp.saveExceptionReportFile(e,"DeckOptionsSaveConf");
    setResult(DeckPicker.RESULT_DB_ERROR);
    finish();
  }
  cacheValues();
  updateSummaries();
  for (  OnSharedPreferenceChangeListener listener : listeners) {
    listener.onSharedPreferenceChanged(DeckPreferenceHack.this,null);
  }
  return true;
}
