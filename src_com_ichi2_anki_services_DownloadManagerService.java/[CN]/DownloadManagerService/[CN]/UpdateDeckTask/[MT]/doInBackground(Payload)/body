{
  Payload data=doInBackgroundLoadDeck(args);
  if (data.returnType == DeckTask.DECK_LOADED) {
    double now=System.currentTimeMillis();
    HashMap<String,Object> results=(HashMap<String,Object>)data.result;
    Deck deck=(Deck)results.get("deck");
    SharedDeckDownload download=(SharedDeckDownload)args[0].data[0];
    SharedPreferences pref=PrefSettings.getSharedPrefs(getBaseContext());
    String updatedCardsPref="numUpdatedCards:" + mDestination + "/tmp/"+ download.getTitle()+ ".anki.updating";
    long totalCards=deck.getCardCount();
    long updatedCards=pref.getLong(updatedCardsPref,0);
    long batchSize=Math.max(100,totalCards / 200);
    download.setNumTotalCards((int)totalCards);
    recentBatchTimings=new long[runningAvgLength];
    totalBatches=((double)totalCards) / batchSize;
    int currentBatch=(int)(updatedCards / batchSize);
    long runningAvgCount=0;
    long batchStart;
    elapsedTime=0;
    while (updatedCards < totalCards) {
      batchStart=System.currentTimeMillis();
      updatedCards=deck.updateAllCardsFromPosition(updatedCards,batchSize);
      Editor editor=pref.edit();
      editor.putLong(updatedCardsPref,updatedCards);
      editor.commit();
      download.setNumUpdatedCards((int)updatedCards);
      publishProgress();
      estimateTimeToCompletion(download,currentBatch,runningAvgCount,System.currentTimeMillis() - batchStart);
      currentBatch++;
      runningAvgCount++;
    }
    Log.i(TAG,"Time to update deck = " + download.getEstTimeToCompletion() + " sec.");
  }
 else {
    data.success=false;
  }
  return data;
}
