{
  Payload data=doInBackgroundLoadDeck(args);
  if (data.returnType == DeckTask.DECK_LOADED) {
    double now=System.currentTimeMillis();
    HashMap<String,Object> results=(HashMap<String,Object>)data.result;
    Deck deck=(Deck)results.get("deck");
    SharedDeckDownload download=(SharedDeckDownload)args[0].data[0];
    SharedPreferences pref=PrefSettings.getSharedPrefs(getBaseContext());
    String updatedCardsPref="numUpdatedCards:" + mDestination + "/tmp/"+ download.getTitle()+ ".anki.updating";
    long totalCards=deck.getCardCount();
    long updatedCards=pref.getLong(updatedCardsPref,0);
    long batchSize=Math.max(100,totalCards / 100);
    download.setNumTotalCards((int)totalCards);
    while (updatedCards < totalCards) {
      updatedCards=deck.updateAllCardsFromPosition(updatedCards,batchSize);
      Editor editor=pref.edit();
      editor.putLong(updatedCardsPref,updatedCards);
      editor.commit();
      download.setNumUpdatedCards((int)updatedCards);
      publishProgress();
    }
    Log.i(TAG,"Time to update deck = " + (System.currentTimeMillis() - now) / 1000.0 + " sec.");
  }
 else {
    data.success=false;
  }
  return data;
}
