{
  if (mFileList != null && mFileList.length > 0) {
    mLock.lock();
    try {
      mIsFinished=false;
      int i=0;
      for (      File file : mFileList) {
        i++;
        if (mDeckIsSelected) {
          break;
        }
        String path=file.getAbsolutePath();
        Deck deck;
        Bundle data=new Bundle();
        Message msg;
        if (BackupManager.isActivated() && BackupManager.safetyBackupNeeded(path,BackupManager.SAFETY_BACKUP_THRESHOLD)) {
          data.putString("absPath",path);
          data.putInt("msgtype",MSG_CREATING_BACKUP);
          msg=Message.obtain();
          msg.setData(data);
          mHandler.sendMessage(msg);
          if (BackupManager.backupDeck(path) == BackupManager.RETURN_BACKUP_CREATED) {
            data.putString("absPath",path);
            data.putInt("msgtype",MSG_LOADING_DECK);
            msg=Message.obtain();
            msg.setData(data);
            mHandler.sendMessage(msg);
          }
 else {
            data.putString("absPath",path);
            data.putInt("msgtype",MSG_BACKUP_ERROR);
            msg=Message.obtain();
            msg.setData(data);
            mHandler.sendMessage(msg);
            continue;
          }
        }
        int version=0;
        try {
          version=Deck.getDeckVersion(path);
        }
 catch (        Exception e) {
          Log.w(AnkiDroidApp.TAG,"Could not open database " + path);
          addBrokenDeck(path);
          data.putString("absPath",path);
          data.putInt("msgtype",MSG_COULD_NOT_BE_LOADED);
          msg=Message.obtain();
          msg.setData(data);
          mHandler.sendMessage(msg);
          continue;
        }
        if (version < Deck.DECK_VERSION) {
          data.putString("absPath",path);
          data.putInt("msgtype",MSG_UPGRADE_NEEDED);
          data.putInt("version",version);
          data.putString("notes","");
          msg=Message.obtain();
          msg.setData(data);
          mHandler.sendMessage(msg);
        }
        deck=DeckManager.getDeck(path,DeckManager.REQUESTING_ACTIVITY_DECKPICKER,false);
        if (deck == null) {
          addBrokenDeck(path);
          data.putString("absPath",path);
          data.putInt("msgtype",MSG_COULD_NOT_BE_LOADED);
          msg=Message.obtain();
          msg.setData(data);
          mHandler.sendMessage(msg);
          continue;
        }
        version=deck.getVersion();
        if (version < Deck.DECK_VERSION) {
          data.putString("absPath",path);
          data.putInt("msgtype",MSG_UPGRADE_FAILURE);
          data.putInt("version",version);
          data.putString("notes",Deck.upgradeNotesToMessages(deck,getResources()));
          DeckManager.closeDeck(path,DeckManager.REQUESTING_ACTIVITY_DECKPICKER);
          msg=Message.obtain();
          msg.setData(data);
          mHandler.sendMessage(msg);
        }
 else {
          try {
            int dueCards=deck.getDueCount();
            int totalCards=deck.getCardCount();
            int newCards=deck.getNewCountToday();
            int totalNewCards=deck.getNewCount(mCompletionBarRestrictToActive);
            int matureCards=deck.getMatureCardCount(mCompletionBarRestrictToActive);
            int totalRevCards=deck.getTotalRevFailedCount(mCompletionBarRestrictToActive);
            int totalCardsCompletionBar=totalRevCards + totalNewCards;
            double modified=deck.getModified();
            String upgradeNotes=Deck.upgradeNotesToMessages(deck,getResources());
            DeckManager.closeDeck(path,DeckManager.REQUESTING_ACTIVITY_DECKPICKER);
            data.putString("absPath",path);
            data.putInt("msgtype",MSG_UPGRADE_SUCCESS);
            data.putInt("due",dueCards);
            data.putDouble("mod",modified);
            data.putInt("total",totalCards);
            data.putInt("new",newCards);
            data.putInt("totalNew",totalNewCards);
            data.putString("notes",upgradeNotes);
            int rateOfCompletionMat;
            int rateOfCompletionAll;
            if (totalCardsCompletionBar != 0) {
              rateOfCompletionMat=(matureCards * 100) / totalCardsCompletionBar;
              rateOfCompletionAll=(totalRevCards * 100) / totalCardsCompletionBar;
            }
 else {
              rateOfCompletionMat=0;
              rateOfCompletionAll=0;
            }
            data.putInt("rateOfCompletionMat",rateOfCompletionMat);
            data.putInt("rateOfCompletionAll",Math.max(0,rateOfCompletionAll - rateOfCompletionMat));
            msg=Message.obtain();
            msg.setData(data);
            mTotalDueCards+=dueCards + newCards;
            mTotalCards+=totalCards;
            mTotalTime+=Math.max(deck.getETA(),0);
          }
 catch (          SQLiteException e) {
            Log.e(AnkiDroidApp.TAG,"DeckPicker - run - error on loading deck values from file " + path + ": "+ e);
            data.putString("absPath",path);
            data.putInt("msgtype",MSG_COULD_NOT_BE_LOADED);
            msg=Message.obtain();
            msg.setData(data);
            mHandler.sendMessage(msg);
            addBrokenDeck(path);
            continue;
          }
          mHandler.sendMessage(msg);
        }
      }
      mIsFinished=true;
      mHandler.sendEmptyMessage(0);
      mCondFinished.signal();
    }
 catch (    Exception e) {
      throw new RuntimeException(e);
    }
 finally {
      mLock.unlock();
    }
  }
}
