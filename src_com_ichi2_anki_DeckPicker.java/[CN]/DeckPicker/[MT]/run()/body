{
  Log.i(AnkiDroidApp.TAG,"Thread run - Beginning");
  if (mFileList != null && mFileList.length > 0) {
    mLock.lock();
    try {
      Log.i(AnkiDroidApp.TAG,"Thread run - Inside lock");
      mIsFinished=false;
      int i=0;
      for (      File file : mFileList) {
        i++;
        Log.i(AnkiDroidApp.TAG,"Thread run - Before break mDeckIsSelected = " + mDeckIsSelected);
        if (mDeckIsSelected) {
          break;
        }
        String path=file.getAbsolutePath();
        Deck deck;
        int version=0;
        try {
          version=Deck.getDeckVersion(path);
        }
 catch (        SQLException e) {
          Log.w(AnkiDroidApp.TAG,"Could not open database " + path);
          continue;
        }
        if (version < Deck.DECK_VERSION) {
          Bundle data=new Bundle();
          data.putString("absPath",path);
          data.putInt("msgtype",MSG_UPGRADE_NEEDED);
          data.putInt("version",version);
          data.putString("notes","");
          Message msg=Message.obtain();
          msg.setData(data);
          mHandler.sendMessage(msg);
        }
        boolean openedDeck=false;
        try {
          if (mCurrentLoadedDeckPath != null && path.equals(mCurrentLoadedDeckPath)) {
            deck=AnkiDroidApp.deck();
            openedDeck=true;
          }
 else {
            deck=Deck.openDeck(path,false);
          }
          version=deck.getVersion();
        }
 catch (        SQLException e) {
          Log.w(AnkiDroidApp.TAG,"Could not open database " + path);
          continue;
        }
        Bundle data=new Bundle();
        Message msg=Message.obtain();
        if (version < Deck.DECK_VERSION) {
          data.putString("absPath",path);
          data.putInt("msgtype",MSG_UPGRADE_FAILURE);
          data.putInt("version",version);
          data.putString("notes",Deck.upgradeNotesToMessages(deck,getResources()));
          if (!openedDeck) {
            deck.closeDeck(false);
          }
          msg.setData(data);
          mHandler.sendMessage(msg);
        }
 else {
          int dueCards=deck.getDueCount();
          int totalCards=deck.getCardCount();
          int newCards=deck.getNewCountToday();
          int totalNewCards=deck.getNewCount(mCompletionBarRestrictToActive);
          int matureCards=deck.getMatureCardCount(mCompletionBarRestrictToActive);
          int totalRevCards=deck.getTotalRevFailedCount(mCompletionBarRestrictToActive);
          int totalCardsCompletionBar=totalRevCards + totalNewCards;
          String upgradeNotes=Deck.upgradeNotesToMessages(deck,getResources());
          if (!openedDeck) {
            deck.closeDeck(false);
          }
          data.putString("absPath",path);
          data.putInt("msgtype",MSG_UPGRADE_SUCCESS);
          data.putInt("due",dueCards);
          data.putInt("total",totalCards);
          data.putInt("new",newCards);
          data.putInt("totalNew",totalNewCards);
          data.putString("notes",upgradeNotes);
          int rateOfCompletionMat;
          int rateOfCompletionAll;
          if (totalCardsCompletionBar != 0) {
            rateOfCompletionMat=(matureCards * 100) / totalCardsCompletionBar;
            rateOfCompletionAll=(totalRevCards * 100) / totalCardsCompletionBar;
          }
 else {
            rateOfCompletionMat=0;
            rateOfCompletionAll=0;
          }
          data.putInt("rateOfCompletionMat",rateOfCompletionMat);
          data.putInt("rateOfCompletionAll",Math.max(0,rateOfCompletionAll - rateOfCompletionMat));
          if (i == mFileList.length) {
            data.putBoolean("lastDeck",true);
          }
 else {
            data.putBoolean("lastDeck",false);
          }
          msg.setData(data);
          mTotalDueCards+=dueCards;
          mTotalCards+=totalCards;
          mTotalTime+=Math.max(deck.getETA(),0);
          mHandler.sendMessage(msg);
        }
      }
      mIsFinished=true;
      mHandler.sendEmptyMessage(0);
      mCondFinished.signal();
    }
 catch (    Exception e) {
      throw new RuntimeException(e);
    }
 finally {
      mLock.unlock();
    }
  }
}
