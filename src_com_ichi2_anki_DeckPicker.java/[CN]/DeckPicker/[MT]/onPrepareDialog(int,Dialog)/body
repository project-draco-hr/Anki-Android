{
  Resources res=getResources();
  StyledDialog ad=(StyledDialog)dialog;
switch (id) {
case DIALOG_DELETE_DECK:
    mCurrentDid=Long.parseLong(mDeckList.get(mContextMenuPosition).get("did"));
  ad.setMessage(String.format(res.getString(R.string.delete_deck_message),"\'" + mCol.getDecks().name(mCurrentDid) + "\'"));
break;
case DIALOG_CONTEXT_MENU:
mCurrentDid=Long.parseLong(mDeckList.get(mContextMenuPosition).get("did"));
ad.setTitle(mCol.getDecks().name(mCurrentDid));
break;
case DIALOG_SYNC_LOG:
ad.setMessage(mDialogMessage);
break;
case DIALOG_DB_ERROR:
ad.getButton(Dialog.BUTTON3).setEnabled(hasErrorFiles());
break;
case DIALOG_ERROR_HANDLING:
ArrayList<String> options=new ArrayList<String>();
ArrayList<Integer> values=new ArrayList<Integer>();
if (mCol == null) {
options.add(res.getString(R.string.backup_retry_opening));
values.add(0);
}
 else {
options.add(res.getString(R.string.check_db));
values.add(1);
}
options.add(res.getString(R.string.backup_error_menu_repair));
values.add(2);
options.add(res.getString(R.string.backup_restore));
values.add(3);
options.add(res.getString(R.string.backup_full_sync_from_server));
values.add(4);
options.add(res.getString(R.string.backup_del_collection));
values.add(5);
String[] titles=new String[options.size()];
mRepairValues=new int[options.size()];
for (int i=0; i < options.size(); i++) {
titles[i]=options.get(i);
mRepairValues[i]=values.get(i);
}
ad.setSingleChoiceItems(titles,0,new DialogInterface.OnClickListener(){
@Override public void onClick(DialogInterface dialog,int which){
switch (mRepairValues[which]) {
case 0:
loadCollection();
return;
case 1:
integrityCheck();
return;
case 2:
showDialog(DIALOG_REPAIR_COLLECTION);
return;
case 3:
return;
case 4:
showDialog(DIALOG_FULL_SYNC_FROM_SERVER);
return;
case 5:
showDialog(DIALOG_NEW_COLLECTION);
return;
}
}
}
);
break;
}
}
