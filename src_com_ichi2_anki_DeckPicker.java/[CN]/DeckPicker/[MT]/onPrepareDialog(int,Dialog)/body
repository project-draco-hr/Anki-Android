{
  Resources res=getResources();
  StyledDialog ad=(StyledDialog)dialog;
switch (id) {
case DIALOG_DELETE_DECK:
    if (AnkiDroidApp.colIsOpen() || mDeckList == null || mDeckList.size() == 0) {
      return;
    }
  mCurrentDid=Long.parseLong(mDeckList.get(mContextMenuPosition).get("did"));
ad.setMessage(String.format(res.getString(R.string.delete_deck_message),"\'" + AnkiDroidApp.getCol().getDecks().name(mCurrentDid) + "\'"));
break;
case DIALOG_CONTEXT_MENU:
if (!AnkiDroidApp.colIsOpen() || mDeckList == null || mDeckList.size() == 0) {
return;
}
mCurrentDid=Long.parseLong(mDeckList.get(mContextMenuPosition).get("did"));
ad.setTitle(AnkiDroidApp.getCol().getDecks().name(mCurrentDid));
break;
case DIALOG_IMPORT_LOG:
case DIALOG_SYNC_LOG:
case DIALOG_SYNC_ERROR:
ad.setMessage(mDialogMessage);
break;
case DIALOG_DB_ERROR:
mLoadFailed=false;
ad.getButton(Dialog.BUTTON3).setEnabled(hasErrorFiles());
break;
case DIALOG_LOAD_FAILED:
mLoadFailed=true;
if (mOpenCollectionDialog != null && mOpenCollectionDialog.isShowing()) {
mOpenCollectionDialog.setMessage(res.getString(R.string.col_load_failed));
}
break;
case DIALOG_ERROR_HANDLING:
ArrayList<String> options=new ArrayList<String>();
ArrayList<Integer> values=new ArrayList<Integer>();
if (AnkiDroidApp.getCol() == null) {
options.add(res.getString(R.string.backup_retry_opening));
values.add(0);
}
 else {
options.add(res.getString(R.string.check_db));
values.add(1);
}
options.add(res.getString(R.string.backup_error_menu_repair));
values.add(2);
options.add(res.getString(R.string.backup_restore));
values.add(3);
options.add(res.getString(R.string.backup_full_sync_from_server));
values.add(4);
options.add(res.getString(R.string.backup_del_collection));
values.add(5);
String[] titles=new String[options.size()];
mRepairValues=new int[options.size()];
for (int i=0; i < options.size(); i++) {
titles[i]=options.get(i);
mRepairValues[i]=values.get(i);
}
ad.setItems(titles,new DialogInterface.OnClickListener(){
@Override public void onClick(DialogInterface dialog,int which){
switch (mRepairValues[which]) {
case 0:
loadCollection();
return;
case 1:
integrityCheck();
return;
case 2:
showDialog(DIALOG_REPAIR_COLLECTION);
return;
case 3:
showDialog(DIALOG_RESTORE_BACKUP);
return;
case 4:
showDialog(DIALOG_FULL_SYNC_FROM_SERVER);
return;
case 5:
showDialog(DIALOG_NEW_COLLECTION);
return;
}
}
}
);
break;
case DIALOG_IMPORT_SELECT:
List<File> fileList=Utils.getImportableDecks(this);
if (fileList.size() == 0) {
Themes.showThemedToast(DeckPicker.this,getResources().getString(R.string.import_no_file_found),false);
}
ad.setEnabled(fileList.size() != 0);
String[] tts=new String[fileList.size()];
mImportValues=new String[fileList.size()];
for (int i=0; i < tts.length; i++) {
tts[i]=fileList.get(i).getName().replace(".apkg","");
mImportValues[i]=fileList.get(i).getAbsolutePath();
}
ad.setItems(tts,new DialogInterface.OnClickListener(){
@Override public void onClick(DialogInterface dialog,int which){
mImportPath=mImportValues[which];
showDialog(DIALOG_IMPORT);
}
}
);
break;
}
}
