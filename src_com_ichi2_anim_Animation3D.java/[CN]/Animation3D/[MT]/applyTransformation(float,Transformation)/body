{
  float centerX=0;
  float centerY=0;
  final Camera camera=mCamera;
  final Matrix matrix=t.getMatrix();
  camera.save();
  float time;
switch (mAction) {
case ANIMATION_TURN:
    if (mRealTurn) {
      time=interpolatedTime >= 0.5f ? (interpolatedTime - 1.0f) : interpolatedTime;
    }
 else {
      time=interpolatedTime >= 0.5f ? -(interpolatedTime - 1.0f) : interpolatedTime;
    }
  float degrees=time * (mDirection ? -180 : 180);
if (interpolatedTime >= 0.5f && !mFlipped) {
  mReviewer.fillFlashcard(false);
  mFlipped=true;
}
camera.translate(0.0f,0.0f,mDepthZ * Math.abs(degrees));
if (mDirection) {
centerX=mValueX / 2;
centerY=mValueY / (mRealTurn ? 2 : 3);
camera.rotateX(degrees);
}
 else {
centerX=mValueX / (mRealTurn ? 2 : 3);
centerY=mValueY / 2;
camera.rotateY(degrees);
}
break;
case ANIMATION_EXCHANGE_CARD:
if (mDirection) {
time=interpolatedTime >= 0.5f ? -(interpolatedTime - 1.0f) : -interpolatedTime;
}
 else {
time=interpolatedTime >= 0.5f ? (interpolatedTime - 1.0f) : interpolatedTime;
}
if (interpolatedTime >= 0.5f && !mFlipped) {
mReviewer.fillFlashcard(false);
mFlipped=true;
}
camera.translate(mValueX * time * 2,0.0f,mDepthZ * Math.abs(time * 180));
centerX=mValueX / 2;
centerY=mValueY / 2;
break;
case ANIMATION_SLIDE_IN_CARD:
if (mDirection) {
time=1 - interpolatedTime;
}
 else {
time=-1 + interpolatedTime;
}
if (interpolatedTime >= 0.0f && !mFlipped) {
mReviewer.fillFlashcard(false);
mFlipped=true;
}
camera.translate(mValueX * time * 2,0.0f,mDepthZ * Math.abs(time * 180));
centerX=mValueX / 2;
centerY=mValueY / 2;
break;
}
camera.getMatrix(matrix);
camera.restore();
matrix.preTranslate(-centerX,-centerY);
matrix.postTranslate(centerX,centerY);
}
