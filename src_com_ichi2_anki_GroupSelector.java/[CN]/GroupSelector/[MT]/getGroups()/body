{
  TreeMap<String,int[]> groups=mDeck.getSched().groupCountTree();
  for (  Map.Entry<String,int[]> g : groups.entrySet()) {
    HashMap<String,String> map=new HashMap<String,String>();
    String[] name=g.getKey().split("::");
    StringBuilder sb=new StringBuilder();
    for (int i=0; i < name.length - 1; i++) {
      sb.append("    ");
    }
    sb.append("\u25bd ").append(name[name.length - 1]);
    map.put("name",sb.toString());
    map.put("fullname",g.getKey());
    map.put("conf","nix");
    map.put("all",Integer.toString(g.getValue()[1]));
    map.put("due",Integer.toString(g.getValue()[2]));
    map.put("new",Integer.toString(g.getValue()[3]));
    map.put("gid",Integer.toString(g.getValue()[0]));
    mGroups.add(map);
  }
  ArrayList<Integer> selectedGroups=new ArrayList<Integer>();
  try {
    JSONArray ja=mDeck.getQconf().getJSONArray("groups");
    for (int i=0; i < ja.length(); i++) {
      selectedGroups.add(ja.getInt(i));
    }
  }
 catch (  JSONException e) {
    throw new RuntimeException(e);
  }
  for (int i=0; i < mGroups.size(); i++) {
    String fullname=mGroups.get(i).get("fullname");
    if (i < mGroups.size() - 1 && mGroups.get(i + 1).get("fullname").startsWith(fullname + "::")) {
      mGroupStatus.put(fullname,new Boolean[]{true,true,true,selectedGroups.contains(Integer.parseInt(mGroups.get(i).get("gid")))});
    }
 else {
      changeCaption(mGroups.get(i),ARROW_NONE);
      mGroupStatus.put(fullname,new Boolean[]{true,false,false,selectedGroups.contains(Integer.parseInt(mGroups.get(i).get("gid")))});
    }
  }
  mAllGroups.addAll(mGroups);
  mGroupsAdapter.notifyDataSetChanged();
}
