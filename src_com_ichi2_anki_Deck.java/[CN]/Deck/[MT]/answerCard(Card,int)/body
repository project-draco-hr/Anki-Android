{
  Log.i(TAG,"answerCard");
  double start=System.currentTimeMillis();
  Cursor cursor=null;
  String undoName="Answer Card";
  setUndoStart(undoName);
  double now=System.currentTimeMillis() / 1000.0;
  AnkiDb ankiDB=AnkiDatabaseManager.getDatabase(deckPath);
  String oldState=cardState(card);
  double lastDelaySecs=System.currentTimeMillis() / 1000.0 - card.combinedDue;
  double lastDelay=lastDelaySecs / 86400.0;
  int oldSuc=card.successive;
  Log.e(TAG,"answerCard - phase 1 in " + (System.currentTimeMillis() - start) + " ms.");
  start=System.currentTimeMillis();
  double last=card.interval;
  card.interval=nextInterval(card,ease);
  if (lastDelay >= 0)   card.lastInterval=last;
  if (card.reps != 0)   card.lastDue=card.due;
  card.due=nextDue(card,ease,oldState);
  card.isDue=0;
  card.lastFactor=card.factor;
  if (lastDelay >= 0)   updateFactor(card,ease);
  Log.e(TAG,"answerCard - update card details in " + (System.currentTimeMillis() - start) + " ms.");
  start=System.currentTimeMillis();
  double space, spaceFactor, minSpacing, minOfOtherCards;
  try {
    cursor=ankiDB.database.rawQuery("SELECT models.initialSpacing, models.spacing " + "FROM facts, models " + "WHERE facts.modelId = models.id and "+ "facts.id = "+ card.factId,null);
    if (!cursor.moveToFirst()) {
      minSpacing=0;
      spaceFactor=0;
    }
 else {
      minSpacing=cursor.getDouble(0);
      spaceFactor=cursor.getDouble(1);
    }
  }
  finally {
    if (cursor != null)     cursor.close();
  }
  Log.e(TAG,"answerCard - spacing in " + (System.currentTimeMillis() - start) + " ms.");
  start=System.currentTimeMillis();
  try {
    cursor=ankiDB.database.rawQuery("SELECT min(interval) " + "FROM cards " + "WHERE factId = " + card.factId + " and id != "+ card.id,null);
    if (!cursor.moveToFirst())     minOfOtherCards=0;
 else     minOfOtherCards=cursor.getDouble(0);
  }
  finally {
    if (cursor != null)     cursor.close();
  }
  Log.e(TAG,"answerCard - raw query select in " + (System.currentTimeMillis() - start) + " ms.");
  start=System.currentTimeMillis();
  if (minOfOtherCards != 0)   space=Math.min(minOfOtherCards,card.interval);
 else   space=0;
  space=space * spaceFactor * 86400.0;
  space=Math.max(minSpacing,space);
  space+=System.currentTimeMillis() / 1000.0;
  card.combinedDue=Math.max(card.due,space);
  String extra;
  if (this.reviewEarly)   extra="";
 else {
    extra="or id = " + card.id;
  }
  Log.e(TAG,"answerCard - check other cards in " + (System.currentTimeMillis() - start) + " ms.");
  start=System.currentTimeMillis();
  try {
    cursor=ankiDB.database.rawQuery("SELECT type, count(type) " + "FROM cards " + "WHERE factId = " + card.factId + " and "+ "(isDue = 1 "+ extra+ ") "+ "GROUP BY type",null);
    while (cursor.moveToNext()) {
      Log.i(TAG,"failedSoonCount before = " + failedSoonCount);
      Log.i(TAG,"revCount before = " + revCount);
      Log.i(TAG,"newCount before = " + newCount);
      if (cursor.getInt(0) == 0)       failedSoonCount-=cursor.getInt(1);
 else       if (cursor.getInt(0) == 1)       revCount-=cursor.getInt(1);
 else       newCount-=cursor.getInt(1);
      Log.i(TAG,"failedSoonCount after = " + failedSoonCount);
      Log.i(TAG,"revCount after = " + revCount);
      Log.i(TAG,"newCount after = " + newCount);
    }
  }
  finally {
    if (cursor != null)     cursor.close();
  }
  Log.e(TAG,"answerCard - check counts in " + (System.currentTimeMillis() - start) + " ms.");
  start=System.currentTimeMillis();
  ankiDB.space_other_cards.bindDouble(1,space);
  ankiDB.space_other_cards.bindDouble(2,space);
  ankiDB.space_other_cards.bindDouble(3,now);
  ankiDB.space_other_cards.bindLong(4,card.factId);
  ankiDB.space_other_cards.execute();
  Log.e(TAG,"answerCard - space cards 2 in " + (System.currentTimeMillis() - start) + " ms.");
  start=System.currentTimeMillis();
  String where_id[]=new String[]{new Long(card.id).toString()};
  if (reviewEarly && lastDelay < 0) {
    if (oldSuc != 0 || lastDelaySecs > delay0 || !showFailedLast()) {
      card.priority=-1;
      ContentValues valpriority=new ContentValues(1);
      valpriority.put("priority",card.priority);
      ankiDB.database.update("cards",valpriority,"id = ?",where_id);
    }
  }
  card.updateStats(ease,oldState);
  Log.e(TAG,"answerCard - update stats in " + (System.currentTimeMillis() - start) + " ms.");
  start=System.currentTimeMillis();
  start=System.currentTimeMillis();
  if (card.successive != 0)   card.type=1;
 else   card.type=0;
  int sti=(oldState == "new") ? 0 : 1;
  Log.w(TAG,"sti = " + sti + " "+ ease);
  ankiDB.space_card[sti][ease].bindDouble(1,card.interval);
  ankiDB.space_card[sti][ease].bindDouble(2,card.lastInterval);
  ankiDB.space_card[sti][ease].bindDouble(3,card.due);
  ankiDB.space_card[sti][ease].bindDouble(4,card.lastDue);
  ankiDB.space_card[sti][ease].bindDouble(5,card.factor);
  ankiDB.space_card[sti][ease].bindDouble(6,card.lastFactor);
  ankiDB.space_card[sti][ease].bindDouble(7,card.firstAnswered);
  ankiDB.space_card[sti][ease].bindLong(8,card.reps);
  ankiDB.space_card[sti][ease].bindLong(9,card.successive);
  ankiDB.space_card[sti][ease].bindDouble(10,card.averageTime);
  ankiDB.space_card[sti][ease].bindDouble(11,card.reviewTime);
  if (oldState == "new") {
switch (ease) {
case 0:
      ankiDB.space_card[sti][ease].bindLong(12,card.youngEase0);
    break;
case 1:
  ankiDB.space_card[sti][ease].bindLong(12,card.youngEase1);
break;
case 2:
ankiDB.space_card[sti][ease].bindLong(12,card.youngEase2);
break;
case 3:
ankiDB.space_card[sti][ease].bindLong(12,card.youngEase3);
break;
case 4:
ankiDB.space_card[sti][ease].bindLong(12,card.youngEase4);
break;
default :
}
}
 else {
switch (ease) {
case 0:
ankiDB.space_card[sti][ease].bindLong(12,card.matureEase0);
break;
case 1:
ankiDB.space_card[sti][ease].bindLong(12,card.matureEase1);
break;
case 2:
ankiDB.space_card[sti][ease].bindLong(12,card.matureEase2);
break;
case 3:
ankiDB.space_card[sti][ease].bindLong(12,card.matureEase3);
break;
case 4:
ankiDB.space_card[sti][ease].bindLong(12,card.matureEase4);
break;
default :
}
}
ankiDB.space_card[sti][ease].bindLong(13,card.yesCount);
ankiDB.space_card[sti][ease].bindLong(14,card.noCount);
ankiDB.space_card[sti][ease].bindDouble(15,card.spaceUntil);
ankiDB.space_card[sti][ease].bindDouble(16,Math.max(card.spaceUntil,card.due));
ankiDB.space_card[sti][ease].bindLong(17,card.type);
ankiDB.space_card[sti][ease].bindLong(18,card.id);
ankiDB.space_card[sti][ease].execute();
Log.e(TAG,"answerCard - card todb 2 in " + (System.currentTimeMillis() - start) + " ms.");
Card card1=new Card(this);
card1.fromDB(card.id);
String card1str="id=" + card1.id + " cardid="+ card1.factId+ " cardModelId="+ card1.cardModelId+ " created="+ card1.created+ " tags="+ card1.tags+ " ordinal="+ card1.ordinal+ " priority="+ card1.priority+ " interval="+ card1.interval+ " lastInterval="+ card1.lastInterval+ " due="+ card1.due+ " lastDue="+ card1.lastDue+ " factor="+ card1.factor+ " lastFactor="+ card1.lastFactor+ " firstAnswered="+ card1.firstAnswered+ " reps="+ card1.reps+ " successive="+ card1.successive+ " averageTime="+ card1.averageTime+ " reviewTime="+ card1.reviewTime+ " youngEase0="+ card1.youngEase0+ " youngEase1="+ card1.youngEase1+ " youngEase2="+ card1.youngEase2+ " youngEase3="+ card1.youngEase3+ " youngEase4="+ card1.youngEase4+ " matureEase0="+ card1.matureEase0+ " matureEase1="+ card1.matureEase1+ " matureEase2="+ card1.matureEase2+ " matureEase3="+ card1.matureEase3+ " matureEase4="+ card1.matureEase4+ " yesCount="+ card1.yesCount+ " noCount="+ card1.noCount+ " spaceUntil="+ card1.spaceUntil+ " isDue="+ card1.isDue+ " type="+ card1.type+ " combinedDue="+ card1.combinedDue;
start=System.currentTimeMillis();
card.toDB();
Log.e(TAG,"answerCard - card todb in " + (System.currentTimeMillis() - start) + " ms.");
Card card2=new Card(this);
card2.fromDB(card.id);
String card2str="id=" + card2.id + " cardid="+ card2.factId+ " cardModelId="+ card2.cardModelId+ " created="+ card2.created+ " tags="+ card2.tags+ " ordinal="+ card2.ordinal+ " priority="+ card2.priority+ " interval="+ card2.interval+ " lastInterval="+ card2.lastInterval+ " due="+ card2.due+ " lastDue="+ card2.lastDue+ " factor="+ card2.factor+ " lastFactor="+ card2.lastFactor+ " firstAnswered="+ card2.firstAnswered+ " reps="+ card2.reps+ " successive="+ card2.successive+ " averageTime="+ card2.averageTime+ " reviewTime="+ card2.reviewTime+ " youngEase0="+ card2.youngEase0+ " youngEase1="+ card2.youngEase1+ " youngEase2="+ card2.youngEase2+ " youngEase3="+ card2.youngEase3+ " youngEase4="+ card2.youngEase4+ " matureEase0="+ card2.matureEase0+ " matureEase1="+ card2.matureEase1+ " matureEase2="+ card2.matureEase2+ " matureEase3="+ card2.matureEase3+ " matureEase4="+ card2.matureEase4+ " yesCount="+ card2.yesCount+ " noCount="+ card2.noCount+ " spaceUntil="+ card2.spaceUntil+ " isDue="+ card2.isDue+ " type="+ card2.type+ " combinedDue="+ card2.combinedDue;
if (card1str.compareTo(card2str) != 0) {
Log.e(TAG,"Alert!!!!! prove valid1: '" + card1str + "' prove valid2 '"+ card2str);
}
start=System.currentTimeMillis();
Stats.updateAllStats(this.globalStats,this.dailyStats,card,ease,oldState);
Log.e(TAG,"answerCard - update all stats in " + (System.currentTimeMillis() - start) + " ms.");
start=System.currentTimeMillis();
CardHistoryEntry entry=new CardHistoryEntry(this,card,ease,lastDelay);
entry.writeSQL();
modified=now;
Log.e(TAG,"answerCard - review history in " + (System.currentTimeMillis() - start) + " ms.");
start=System.currentTimeMillis();
setUndoEnd(undoName);
Log.e(TAG,"answerCard - set undo in " + (System.currentTimeMillis() - start) + " ms.");
}
