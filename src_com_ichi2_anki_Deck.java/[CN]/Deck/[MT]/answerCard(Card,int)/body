{
  Log.i(AnkiDroidApp.TAG,"answerCard");
  Cursor cursor=null;
  String undoName="Answer Card";
  setUndoStart(undoName);
  double now=Utils.now();
  AnkiDb ankiDB=AnkiDatabaseManager.getDatabase(mDeckPath);
  String oldState=card.getState();
  double lastDelaySecs=Utils.now() - card.getCombinedDue();
  double start=System.currentTimeMillis();
  double lastDelay=lastDelaySecs / 86400.0;
  boolean oldIsRev=card.isRev();
  double last=card.getInterval();
  card.setInterval(nextInterval(card,ease));
  if (lastDelay >= 0) {
    card.setLastInterval(last);
  }
  if (!card.isNew()) {
    card.setLastDue(card.getDue());
  }
  card.setDue(nextDue(card,ease,oldState));
  card.setIsDue(0);
  card.setLastFactor(card.getFactor());
  if (lastDelay >= 0) {
    card.updateFactor(ease,mAverageFactor);
  }
  double space;
  double spaceFactor;
  double minSpacing;
  double minOfOtherCards;
  try {
    cursor=ankiDB.getDatabase().rawQuery("SELECT models.initialSpacing, models.spacing " + "FROM facts, models " + "WHERE facts.modelId = models.id and "+ "facts.id = "+ card.getFactId(),null);
    if (!cursor.moveToFirst()) {
      minSpacing=0;
      spaceFactor=0;
    }
 else {
      minSpacing=cursor.getDouble(0);
      spaceFactor=cursor.getDouble(1);
    }
  }
  finally {
    if (cursor != null) {
      cursor.close();
    }
  }
  try {
    cursor=ankiDB.getDatabase().rawQuery("SELECT min(interval) " + "FROM cards " + "WHERE factId = " + card.getFactId() + " and id != "+ card.getId(),null);
    if (!cursor.moveToFirst()) {
      minOfOtherCards=0;
    }
 else {
      minOfOtherCards=cursor.getDouble(0);
    }
  }
  finally {
    if (cursor != null) {
      cursor.close();
    }
  }
  if (minOfOtherCards != 0) {
    space=Math.min(minOfOtherCards,card.getInterval());
  }
 else {
    space=0;
  }
  space=space * spaceFactor * 86400.0;
  space=Math.max(minSpacing,space);
  space+=Utils.now();
  card.setCombinedDue(Math.max(card.getDue(),space));
  String extra;
  if (mReviewEarly) {
    extra="";
  }
 else {
    extra="or id = " + card.getId();
  }
  try {
    cursor=ankiDB.getDatabase().rawQuery("SELECT type, count(type) " + "FROM cards " + "WHERE factId = " + card.getFactId() + " and "+ "(isDue = 1 "+ extra+ ") "+ "GROUP BY type",null);
    while (cursor.moveToNext()) {
      Log.i(AnkiDroidApp.TAG,"failedSoonCount before = " + mFailedSoonCount);
      Log.i(AnkiDroidApp.TAG,"revCount before = " + mRevCount);
      Log.i(AnkiDroidApp.TAG,"newCount before = " + mNewCount);
      if (cursor.getInt(0) == 0) {
        mFailedSoonCount-=cursor.getInt(1);
      }
 else       if (cursor.getInt(0) == 1) {
        mRevCount-=cursor.getInt(1);
      }
 else {
        mNewCount-=cursor.getInt(1);
      }
      Log.i(AnkiDroidApp.TAG,"failedSoonCount after = " + mFailedSoonCount);
      Log.i(AnkiDroidApp.TAG,"revCount after = " + mRevCount);
      Log.i(AnkiDroidApp.TAG,"newCount after = " + mNewCount);
    }
  }
  finally {
    if (cursor != null) {
      cursor.close();
    }
  }
  ankiDB.getDatabase().execSQL(String.format(Utils.ENGLISH_LOCALE,"UPDATE cards " + "SET spaceUntil = %f, " + "combinedDue = max(%f, due), "+ "modified = %f, "+ "isDue = 0 "+ "WHERE id != %d and factId = %d",space,space,now,card.getId(),card.getFactId()));
  card.setSpaceUntil(0);
  if (mReviewEarly && lastDelay < 0) {
    if (oldIsRev || lastDelaySecs > mDelay0 || !showFailedLast()) {
      card.setPriority(Card.PRIORITY_REVIEW_EARLY);
    }
  }
  card.updateStats(ease,oldState);
  card.toDB();
  Stats.updateAllStats(mGlobalStats,mDailyStats,card,ease,oldState);
  CardHistoryEntry entry=new CardHistoryEntry(this,card,ease,lastDelay);
  entry.writeSQL();
  mModified=now;
  setUndoEnd(undoName);
}
