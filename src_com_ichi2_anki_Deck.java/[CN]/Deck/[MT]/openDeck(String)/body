{
  Deck deck=new Deck();
  Log.i("anki","Opening database " + path);
  AnkiDb.openDatabase(path);
  Cursor cursor=AnkiDb.database.rawQuery("SELECT *" + " FROM decks" + " LIMIT 1",null);
  if (cursor.isClosed())   throw new SQLException();
  cursor.moveToFirst();
  deck.id=cursor.getLong(0);
  deck.created=cursor.getFloat(1);
  deck.modified=cursor.getFloat(2);
  deck.description=cursor.getString(3);
  deck.version=cursor.getInt(4);
  deck.currentModelId=cursor.getLong(5);
  deck.syncName=cursor.getString(6);
  deck.lastSync=cursor.getFloat(7);
  deck.hardIntervalMin=cursor.getFloat(8);
  deck.hardIntervalMax=cursor.getFloat(9);
  deck.midIntervalMin=cursor.getFloat(10);
  deck.midIntervalMax=cursor.getFloat(11);
  deck.easyIntervalMin=cursor.getFloat(12);
  deck.easyIntervalMax=cursor.getFloat(13);
  deck.delay0=cursor.getInt(14);
  deck.delay1=cursor.getInt(15);
  deck.delay2=cursor.getInt(16);
  deck.collapseTime=cursor.getFloat(17);
  deck.highPriority=cursor.getString(18);
  deck.medPriority=cursor.getString(19);
  deck.lowPriority=cursor.getString(20);
  deck.suspended=cursor.getString(21);
  deck.newCardOrder=cursor.getInt(22);
  deck.newCardSpacing=cursor.getInt(23);
  deck.failedCardMax=cursor.getInt(24);
  deck.newCardsPerDay=cursor.getInt(25);
  deck.sessionRepLimit=cursor.getInt(26);
  deck.sessionTimeLimit=cursor.getInt(27);
  deck.utcOffset=cursor.getFloat(28);
  deck.cardCount=cursor.getInt(29);
  deck.factCount=cursor.getInt(30);
  deck.failedNowCount=cursor.getInt(31);
  deck.failedSoonCount=cursor.getInt(32);
  deck.revCount=cursor.getInt(33);
  deck.newCount=cursor.getInt(34);
  deck.revCardOrder=cursor.getInt(35);
  Log.i("anki","Read " + cursor.getColumnCount() + " columns from decks table.");
  cursor.close();
  deck.initVars();
  deck.updateDynamicIndices();
  int oldCount=deck.failedSoonCount + deck.revCount + deck.newCount;
  deck.rebuildQueue();
  cursor=AnkiDb.database.rawQuery("SELECT id " + "FROM cards " + "WHERE type in (0,1,2) and "+ "isDue = 0 and "+ "priority in (-1,-2)",null);
  if (cursor.isClosed())   throw new SQLException();
  if (cursor.moveToFirst()) {
    int count=cursor.getCount();
    long[] ids=new long[count];
    for (int i=0; i < count; i++) {
      ids[i]=cursor.getLong(0);
      cursor.moveToNext();
    }
    deck.updatePriorities(ids);
    deck.checkDue();
  }
  cursor.close();
  if ((oldCount != (deck.failedSoonCount + deck.revCount + deck.newCount)) || deck.modifiedSinceSave())   deck.commitToDB();
  return deck;
}
