{
  Log.i(AnkiDroidApp.TAG,"answerCard");
  double now=Utils.now();
  long id=card.getId();
  String undoName=UNDO_TYPE_ANSWER_CARD;
  setUndoStart(undoName,id);
  String oldState=card.getState();
  int oldQueue=cardQueue(card);
  double lastDelaySecs=Utils.now() - card.getCombinedDue();
  double lastDelay=lastDelaySecs / 86400.0;
  boolean oldIsRev=card.isRev();
  ContentValues oldvalues=card.getAnswerValues();
  double last=card.getInterval();
  card.setInterval(nextInterval(card,ease));
  if (lastDelay >= 0) {
    card.setLastInterval(last);
  }
  if (!card.isNew()) {
    card.setLastDue(card.getDue());
  }
  card.setDue(nextDue(card,ease,oldState));
  card.setIsDue(0);
  card.setLastFactor(card.getFactor());
  card.setSpaceUntil(0);
  if (lastDelay >= 0) {
    card.updateFactor(ease,mAverageFactor);
  }
  spaceCards(card);
  if (ease == 1) {
    if (card.getDue() < mFailedCutoff) {
      mFailedSoonCount+=1;
    }
  }
  if (oldQueue == 0) {
    mFailedSoonCount-=1;
  }
 else   if (oldQueue == 1) {
    mRevCount-=1;
  }
 else {
    mNewCount-=1;
  }
  card.updateStats(ease,oldState);
  card.setType(cardType(card));
  card.setRelativeDelay(card.getType());
  if (ease != 1) {
    card.setDue(Math.max(card.getDue(),mDueCutoff + 1));
  }
  if (answerPreSaveMethod != null) {
    answerPreSave(card,ease);
  }
  card.setCombinedDue(card.getDue());
  getDB().update(this,"cards",card.getAnswerValues(),"id = " + id,null,true,new ContentValues[]{oldvalues},new String[]{"id = " + id});
  Stats.updateAllStats(mGlobalStats,mDailyStats,card,ease,oldState);
  CardHistoryEntry entry=new CardHistoryEntry(this,card,ease,lastDelay);
  entry.writeSQL();
  mModified=now;
  setUndoEnd(undoName);
  requeueCard(card,oldIsRev);
  if (isLeech(card)) {
    Log.i(AnkiDroidApp.TAG,"card is leech!");
    handleLeech(card);
  }
}
