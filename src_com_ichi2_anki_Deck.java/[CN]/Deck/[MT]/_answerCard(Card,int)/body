{
  Log.i(TAG,"answerCard");
  String undoName="Answer Card";
  setUndoStart(undoName);
  double now=System.currentTimeMillis() / 1000.0;
  String oldState=cardState(card);
  int oldQueue=cardQueue(card);
  double lastDelaySecs=System.currentTimeMillis() / 1000.0 - card.combinedDue;
  double lastDelay=lastDelaySecs / 86400.0;
  int oldSuc=card.successive;
  double last=card.interval;
  card.interval=nextInterval(card,ease);
  if (lastDelay >= 0) {
    card.lastInterval=last;
  }
  if (card.reps != 0) {
    card.lastDue=card.due;
  }
  card.due=nextDue(card,ease,oldState);
  card.isDue=0;
  card.lastFactor=card.factor;
  card.spaceUntil=0;
  if (lastDelay >= 0) {
    updateFactor(card,ease);
  }
  double space=spaceUntilTime(card);
  spaceCards(card,space);
  if (ease == 1) {
    if (!(oldState.compareTo("mature") == 0 && delay1 != 0)) {
      failedSoonCount+=1;
    }
  }
  if (oldQueue == 0) {
    failedSoonCount-=1;
  }
 else   if (oldQueue == 1) {
    revCount-=1;
  }
 else {
    newCount-=1;
  }
  card.updateStats(ease,oldState);
  card.type=cardType(card);
  card.relativeDelay=card.type;
  if (ease != 1) {
    card.due=Math.max(card.due,dueCutoff + 1);
  }
  if (answerPreSaveMethod != null) {
    answerPreSave(card,ease);
  }
  card.combinedDue=card.due;
  card.toDB();
  Stats.updateAllStats(globalStats,dailyStats,card,ease,oldState);
  CardHistoryEntry entry=new CardHistoryEntry(this,card,ease,lastDelay);
  entry.writeSQL();
  modified=now;
  requeueCard(card,oldSuc);
  if (isLeech(card)) {
    Log.i(TAG,"card is leech!");
    handleLeech(card);
  }
  setUndoEnd(undoName);
}
