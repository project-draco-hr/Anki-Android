{
  UndoRow row;
  while (true) {
    row=src.pop();
    if (row != null) {
      break;
    }
  }
  int start=row.mStart;
  int end=row.mEnd;
  if (end == 0) {
    end=latestUndoRow();
  }
  ArrayList<UndoCommand> commands=new ArrayList<UndoCommand>();
  commands.addAll(mUndoCommands.subList(start,end));
  int newstart=latestUndoRow();
  mRecordUndoInformation=true;
  for (  UndoCommand u : commands) {
    getDB().execSQL(this,u.mCommand,u.mTable,u.mValues,u.mWhereClause);
  }
  mRecordUndoInformation=false;
  mCurrentUndoRedoType=row.mName;
  int newend=latestUndoRow();
  if (newstart != newend) {
    if (inReview) {
      dst.push(new UndoRow(row.mName,row.mCardId,newstart,newend));
    }
 else {
      dst.push(new UndoRow(row.mName,oldCardId,newstart,newend));
    }
  }
  return row.mCardId;
}
