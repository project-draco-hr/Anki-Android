{
  lockDeck(deckpath);
  try {
    if (sLoadedDecks.containsKey(deckpath)) {
      DeckInformation di=sLoadedDecks.get(deckpath);
      if ((di.mClosingAsyncTask != null) && di.mClosingAsyncTask.getStatus() == AsyncTask.Status.RUNNING && !di.mClosingAsyncTask.isCancelled()) {
        Log.i(AnkiDroidApp.TAG,"DeckManager: closeDeck - deck " + deckpath + " is already closing");
        return;
      }
      ArrayList<Integer> openList=sLoadedDecks.get(deckpath).mOpenedBy;
      if (requestingActivity != -1 && !openList.contains(requestingActivity)) {
        Log.e(AnkiDroidApp.TAG,"DeckManager: deck " + deckpath + " is not loaded by "+ requestingActivity);
      }
 else       if (requestingActivity != -1 && openList.size() > 1) {
        openList.remove(new Integer(requestingActivity));
        Log.i(AnkiDroidApp.TAG,"DeckManager: deck " + deckpath + " used still by more activities ("+ openList.toString()+ "), removing only "+ requestingActivity);
        if (requestingActivity == REQUESTING_ACTIVITY_BIGWIDGET) {
        }
      }
 else {
        Log.i(AnkiDroidApp.TAG,"DeckManager: closing deck " + deckpath + " ("+ requestingActivity+ ")");
        sLoadedDecks.get(deckpath).mClosingAsyncTask=new CloseDeckAsyncTask();
        sLoadedDecks.get(deckpath).mClosingAsyncTask.execute(new CloseDeckInformation(deckpath,requestingActivity));
        if (openList.contains(REQUESTING_ACTIVITY_BIGWIDGET)) {
        }
        if (sMainDeckPath != null && sMainDeckPath.equals(deckpath)) {
          sMainDeckPath=null;
        }
      }
    }
 else {
      Log.e(AnkiDroidApp.TAG,"DeckManager: deck " + deckpath + " is not a loaded deck");
    }
  }
  finally {
    unlockDeck(deckpath);
  }
}
