{
  Deck deck=null;
  lockDeck(deckpath);
  try {
    if (sLoadedDecks.containsKey(deckpath)) {
      DeckInformation deckInformation=sLoadedDecks.get(deckpath);
      try {
        AsyncTask<CloseDeckInformation,Void,DeckInformation> closingTask=deckInformation.mClosingAsyncTask;
        if (closingTask != null && closingTask.getStatus() == AsyncTask.Status.RUNNING && !closingTask.isCancelled()) {
          if (deckInformation.mWaitForDeckTaskToFinish) {
            Log.i(AnkiDroidApp.TAG,"DeckManager: deck " + deckpath + " is closing now, cancelling this");
            closingTask.cancel(true);
            deckInformation.mOpenedBy=new ArrayList<Integer>();
          }
 else {
            Log.i(AnkiDroidApp.TAG,"DeckManager: deck " + deckpath + " is closing now, waiting for this to finish and reopening it");
            while (closingTask.getStatus() == AsyncTask.Status.RUNNING) {
              closingTask.get();
            }
            return getDeck(deckpath,setAsMainDeck,doSafetyBackupIfNeeded,requestingActivity,rebuild);
          }
        }
      }
 catch (      Exception e) {
        Log.i(AnkiDroidApp.TAG,"DeckManager: An exception occurred while waiting for closing task of deck " + deckpath);
      }
      ArrayList<Integer> openList=deckInformation.mOpenedBy;
      if (!openList.contains(requestingActivity)) {
        Log.i(AnkiDroidApp.TAG,"DeckManager: deck " + deckpath + " already loaded, adding requesting activity");
        openList.add(requestingActivity);
      }
 else {
        Log.i(AnkiDroidApp.TAG,"DeckManager: deck " + deckpath + " already loaded by this activity!");
      }
      Log.i(AnkiDroidApp.TAG,"DeckManager: deck " + deckpath + " is now opened by "+ openList.toString());
      deck=deckInformation.mDeck;
      if (requestingActivity == REQUESTING_ACTIVITY_SYNCCLIENT) {
        sendWidgetBigClosedNotification();
        deckInformation.mOpenedBy.remove(REQUESTING_ACTIVITY_BIGWIDGET);
        if (!deckInformation.mDeleteJournalModeForced) {
          Cursor cur=null;
          try {
            cur=deck.getDB().getDatabase().rawQuery("PRAGMA journal_mode",null);
            if (cur.moveToFirst()) {
              if (!cur.getString(0).equalsIgnoreCase("delete")) {
                Log.i(AnkiDroidApp.TAG,"DeckManager: Journal mode not set to delete, reloading deck");
                deck.closeDeck();
                deck=Deck.openDeck(deckpath,rebuild,true);
              }
              deckInformation.mDeleteJournalModeForced=true;
            }
          }
  finally {
            if (cur != null && !cur.isClosed()) {
              cur.close();
            }
          }
        }
 else         if (deckInformation.mOpenedBy.contains(REQUESTING_ACTIVITY_SYNCCLIENT)) {
          deck=null;
        }
      }
 else       if (rebuild) {
        if (!deckInformation.mInitiallyRebuilt) {
          Log.i(AnkiDroidApp.TAG,"DeckManager: reopen deck in order to rebuild");
          deck.closeDeck(false);
          deckInformation.mDeck=Deck.openDeck(deckpath,true,requestingActivity == REQUESTING_ACTIVITY_SYNCCLIENT);
          deckInformation.mInitiallyRebuilt=true;
          WidgetStatus.update(AnkiDroidApp.getInstance().getBaseContext(),WidgetStatus.getDeckStatus(deck));
        }
      }
    }
 else {
      try {
        Log.i(AnkiDroidApp.TAG,"DeckManager: try to load deck " + deckpath + " ("+ requestingActivity+ ")");
        if (doSafetyBackupIfNeeded) {
          BackupManager.safetyBackupNeeded(deckpath,BackupManager.SAFETY_BACKUP_THRESHOLD);
        }
        deck=Deck.openDeck(deckpath,rebuild,requestingActivity == REQUESTING_ACTIVITY_SYNCCLIENT);
        Log.i(AnkiDroidApp.TAG,"DeckManager: Deck loaded!");
        sLoadedDecks.put(deckpath,new DeckInformation(deckpath,deck,requestingActivity,rebuild));
      }
 catch (      RuntimeException e) {
        Log.e(AnkiDroidApp.TAG,"DeckManager: deck " + deckpath + " could not be opened = "+ e.getMessage());
        BackupManager.restoreDeckIfMissing(deckpath);
        deck=null;
      }
    }
  }
  finally {
    if (setAsMainDeck && deck != null) {
      sMainDeckPath=deckpath;
    }
    unlockDeck(deckpath);
  }
  return deck;
}
