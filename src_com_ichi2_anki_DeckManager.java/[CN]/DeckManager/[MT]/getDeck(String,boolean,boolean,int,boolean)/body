{
  Deck deck=null;
  mLock.lock();
  mOpeningDeck=deckpath;
  try {
    while (mClosingDeck != null && mClosingDeck.equals(deckpath)) {
      Log.e(AnkiDroidApp.TAG,"DeckManager: waitForDeckClosing (" + deckpath + ")");
      mCondFinished.await();
    }
    if (sLoadedDecks.containsKey(deckpath)) {
      DeckInformation deckInformation=sLoadedDecks.get(deckpath);
      try {
        if ((deckInformation.mClosingAsyncTask != null) && (deckInformation.mClosingAsyncTask.getStatus() != AsyncTask.Status.FINISHED)) {
          Log.e(AnkiDroidApp.TAG,"DeckManager: deck " + deckpath + " is closing now, waiting for this to finish and reopening it");
          deckInformation.mClosingAsyncTask.get();
          return getDeck(deckpath,requestingActivity);
        }
      }
 catch (      Exception e) {
        Log.i(AnkiDroidApp.TAG,"DeckManager: An exception occurred while waiting for closing task of deck " + deckpath);
      }
      ArrayList<Integer> openList=deckInformation.mOpenedBy;
      if (!openList.contains(requestingActivity)) {
        Log.i(AnkiDroidApp.TAG,"DeckManager: deck " + deckpath + " already loaded, adding requesting activity");
        openList.add(requestingActivity);
      }
 else {
        Log.e(AnkiDroidApp.TAG,"DeckManager: deck " + deckpath + " already loaded by this activity!");
      }
      Log.i(AnkiDroidApp.TAG,"DeckManager: deck " + deckpath + " is now opened by "+ openList.toString());
      deck=deckInformation.mDeck;
      if (requestingActivity == REQUESTING_ACTIVITY_SYNCCLIENT) {
        sendWidgetBigClosedNotification();
        deckInformation.mOpenedBy.remove(REQUESTING_ACTIVITY_BIGWIDGET);
        if (!deckInformation.mDeleteJournalModeForced) {
          Cursor cur=null;
          try {
            cur=deck.getDB().getDatabase().rawQuery("PRAGMA journal_mode",null);
            if (cur.moveToFirst()) {
              if (!cur.getString(0).equalsIgnoreCase("delete")) {
                Log.i(AnkiDroidApp.TAG,"DeckManager: Journal mode not set to delete, reloading deck");
                deck.closeDeck();
                deck=Deck.openDeck(deckpath,rebuild,true);
              }
              deckInformation.mDeleteJournalModeForced=true;
            }
          }
  finally {
            if (cur != null && !cur.isClosed()) {
              cur.close();
            }
          }
        }
 else         if (deckInformation.mOpenedBy.contains(REQUESTING_ACTIVITY_SYNCCLIENT)) {
          deck=null;
        }
      }
    }
 else {
      try {
        Log.i(AnkiDroidApp.TAG,"DeckManager: try to load deck " + deckpath + " ("+ requestingActivity+ ")");
        if (doSafetyBackupIfNeeded) {
          BackupManager.safetyBackupNeeded(deckpath,BackupManager.SAFETY_BACKUP_THRESHOLD);
        }
        deck=Deck.openDeck(deckpath,rebuild,requestingActivity == REQUESTING_ACTIVITY_SYNCCLIENT);
        Log.i(AnkiDroidApp.TAG,"DeckManager: Deck loaded!");
        sLoadedDecks.put(deckpath,new DeckInformation(deckpath,deck,requestingActivity,rebuild));
      }
 catch (      RuntimeException e) {
        Log.e(AnkiDroidApp.TAG,"DeckManager: deck " + deckpath + " could not be opened = "+ e.getMessage());
        BackupManager.restoreDeckIfMissing(deckpath);
        deck=null;
      }
    }
    if (setAsMainDeck && deck != null) {
      sMainDeckPath=deckpath;
    }
  }
 catch (  InterruptedException e) {
    e.printStackTrace();
  }
 finally {
    mOpeningDeck=null;
    mCondFinished.signal();
    mLock.unlock();
  }
  return deck;
}
