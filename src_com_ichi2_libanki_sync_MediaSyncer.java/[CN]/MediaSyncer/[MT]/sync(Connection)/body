{
  try {
    con.publishProgress(R.string.sync_media_find);
    Log.i(AnkiDroidApp.TAG,"MediaSyncer: finding changed media");
    mCol.getMedia().findChanges();
    int lastUsn=mCol.getMedia().lastUsn();
    JSONObject ret=mServer.begin();
    int srvUsn=ret.getInt("usn");
    if ((lastUsn == srvUsn) && !(mCol.getMedia().haveDirty())) {
      return "noChanges";
    }
    Log.i(AnkiDroidApp.TAG,"MediaSyncer: Last local usn is: " + lastUsn);
    while (true) {
      JSONArray data=mServer.mediaChanges(lastUsn);
      Log.i(AnkiDroidApp.TAG,"MediaSyncer: mediaChanges resp count: " + data.length());
      if (data.length() == 0) {
        break;
      }
      List<String> need=new ArrayList<String>();
      lastUsn=data.getJSONArray(data.length() - 1).getInt(1);
      for (int i=0; i < data.length(); i++) {
        String fname=data.getJSONArray(i).getString(0);
        int rusn=data.getJSONArray(i).getInt(1);
        String rsum=data.getJSONArray(i).optString(2);
        Pair<String,Integer> info=mCol.getMedia().syncInfo(fname);
        String lsum=info.first;
        int ldirty=info.second;
        Log.v(AnkiDroidApp.TAG,String.format("check: lsum=%s rsum=%s ldirty=%d rusn=%d fname=%s",TextUtils.isEmpty(lsum) ? "" : lsum.subSequence(0,4),TextUtils.isEmpty(rsum) ? "" : rsum.subSequence(0,4),ldirty,rusn,fname));
        if (!TextUtils.isEmpty(rsum)) {
          if (TextUtils.isEmpty(lsum) || !lsum.equals(rsum)) {
            Log.v(AnkiDroidApp.TAG,"will fetch");
            need.add(fname);
          }
 else {
            Log.v(AnkiDroidApp.TAG,"have same already");
          }
          mCol.getMedia().markClean(Arrays.asList(fname));
        }
 else         if (!TextUtils.isEmpty(lsum)) {
          if (ldirty != 0) {
            Log.v(AnkiDroidApp.TAG,"delete local");
            mCol.getMedia().syncDelete(fname);
          }
 else {
            Log.v(AnkiDroidApp.TAG,"conflict; will send");
          }
        }
 else {
          Log.v(AnkiDroidApp.TAG,"both sides deleted");
          mCol.getMedia().markClean(Arrays.asList(fname));
        }
      }
      _downloadFiles(need);
      Log.v(AnkiDroidApp.TAG,"update last usn to " + lastUsn);
      mCol.getMedia().setLastUsn(lastUsn);
    }
    boolean updateConflict=false;
    while (true) {
      Pair<File,List<String>> changesZip=mCol.getMedia().mediaChangesZip();
      File zip=changesZip.first;
      List<String> fnames=changesZip.second;
      if (fnames.size() == 0) {
        break;
      }
      JSONArray changes=mServer.uploadChanges(zip);
      int processedCnt=changes.getInt(0);
      int serverLastUsn=changes.getInt(1);
      mCol.getMedia().markClean(fnames.subList(0,processedCnt));
      Log.v(AnkiDroidApp.TAG,String.format("processed %d, serverUsn %d, clientUsn %d",processedCnt,serverLastUsn,lastUsn));
      if (serverLastUsn - processedCnt == lastUsn) {
        Log.v(AnkiDroidApp.TAG,"lastUsn in sync, updating local");
        lastUsn=serverLastUsn;
        mCol.getMedia().setLastUsn(serverLastUsn);
      }
 else {
        Log.v(AnkiDroidApp.TAG,"concurrent update, skipping usn update");
        mCol.getMedia().getDb().commit();
        updateConflict=true;
      }
    }
    if (updateConflict) {
      Log.v(AnkiDroidApp.TAG,"restart sync due to concurrent update");
      return sync(con);
    }
    int lcnt=mCol.getMedia().mediacount();
    String sRet=mServer.mediaSanity(lcnt);
    if (sRet.equals("OK")) {
      return "OK";
    }
 else {
      mCol.getMedia().forceResync();
      return sRet;
    }
  }
 catch (  JSONException e) {
    throw new RuntimeException(e);
  }
catch (  APIVersionException e) {
    UnsupportedSyncException ee=new UnsupportedSyncException("Cannot sync media on this version of Android");
    Log.e(AnkiDroidApp.TAG,e.getMessage());
    throw ee;
  }
catch (  Exception e) {
    Log.e(AnkiDroidApp.TAG,"Syncing error: ",e);
    throw new RuntimeException(e);
  }
}
