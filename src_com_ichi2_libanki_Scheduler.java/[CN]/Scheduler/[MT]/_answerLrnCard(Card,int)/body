{
  JSONObject conf=_lrnConf(card);
  int type;
  if (card.getType() == 2) {
    type=2;
  }
 else {
    type=0;
  }
  boolean leaving=false;
  try {
    if (ease == 3) {
      _rescheduleAsRev(card,conf,true);
      leaving=true;
    }
 else     if (ease == 2 && card.getGrade() + 1 >= conf.getJSONArray("delays").length()) {
      _rescheduleAsRev(card,conf,false);
      leaving=true;
    }
 else {
      card.setCycles(card.getCycles() + 1);
      if (ease == 2) {
        card.setGrade(card.getGrade() + 1);
      }
 else {
        card.setGrade(0);
      }
      int delay=_delayForGrade(conf,card.getGrade());
      if (card.getDue() < Utils.now()) {
        delay*=(1 + (new Random().nextInt(25) / 100));
      }
      card.setDue((int)(Utils.now() + delay));
      _sortIntoLrn(card.getDue(),card.getId());
      if (delay <= mDeck.getQconf().getInt("collapseTime")) {
        mLrnCount+=1;
      }
    }
  }
 catch (  JSONException e) {
    throw new RuntimeException(e);
  }
  _logLrn(card,ease,conf,leaving,type);
}
