{
  ArrayList<HashMap<String,String>> decksChangelogs=new ArrayList<HashMap<String,String>>();
  String username=(String)data.data[0];
  String password=(String)data.data[1];
  Deck currentDeck=AnkiDroidApp.deck();
  if (currentDeck != null) {
    currentDeck.closeDeck();
    AnkiDroidApp.setDeck(null);
  }
  ArrayList<HashMap<String,String>> decksToSync=(ArrayList<HashMap<String,String>>)data.data[2];
  for (  HashMap<String,String> deckToSync : decksToSync) {
    String deckPath=deckToSync.get("filepath");
    try {
      boolean forceDeleteJournalMode=Deck.isWalEnabled(deckPath);
      Deck deck=Deck.openDeck(deckPath,true,forceDeleteJournalMode);
      Payload syncDeckData=new Payload(new Object[]{username,password,deck,null,false});
      syncDeckData=doInBackgroundSyncDeck(syncDeckData);
      if (deck != null) {
        deck.closeDeck();
      }
      decksChangelogs.add((HashMap<String,String>)syncDeckData.result);
    }
 catch (    Exception e) {
      Log.e(AnkiDroidApp.TAG,"Exception e = " + e.getMessage());
      String deckName=deckPath.substring(deckPath.lastIndexOf("/") + 1);
      deckName=deckName.substring(0,deckName.length() - ".anki".length());
      HashMap<String,String> deckChangelog=new HashMap<String,String>();
      deckChangelog.put("deckName",deckName);
      deckChangelog.put("message",sContext.getResources().getString(R.string.sync_log_error_message));
      decksChangelogs.add(deckChangelog);
    }
  }
  data.result=decksChangelogs;
  return data;
}
