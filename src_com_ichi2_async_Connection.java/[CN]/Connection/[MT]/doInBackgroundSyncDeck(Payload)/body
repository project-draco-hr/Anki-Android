{
  Resources res=context.getResources();
  String username=(String)data.data[0];
  String password=(String)data.data[1];
  Deck deck=(Deck)data.data[2];
  String deckPath=(String)data.data[3];
  String syncName=deck.getSyncName();
  if (syncName == null || syncName.equalsIgnoreCase("")) {
    syncName=deckPath.substring(deckPath.lastIndexOf("/") + 1);
    syncName=syncName.substring(0,syncName.length() - ".anki".length());
    Log.i(TAG,"syncName = *" + syncName + "*");
    deck.setSyncName(syncName);
  }
  AnkiDb ankiDB=AnkiDatabaseManager.getDatabase(deckPath);
  ankiDB.database.beginTransaction();
  try {
    Log.i(TAG,"Starting sync: username = " + username + ", password = "+ password+ ", deckPath = "+ deckPath+ ", syncName = "+ syncName);
    AnkiDroidProxy server=new AnkiDroidProxy(username,password);
    publishProgress(syncName,res.getString(R.string.sync_connecting_message));
    server.connect();
    if (!server.hasDeck(syncName)) {
      Log.i(TAG,"AnkiOnline does not have this deck: Creating it...");
      server.createDeck(syncName);
    }
    int timediff=(int)(server.getTimestamp() - (System.currentTimeMillis() / 1000));
    if (timediff > 300) {
      Log.i(TAG,"The clock is unsynchronized!");
    }
    publishProgress(syncName,res.getString(R.string.sync_syncing_message,new Object[]{syncName}));
    SyncClient client=new SyncClient(deck);
    client.setServer(server);
    server.setDeckName(syncName);
    if (client.prepareSync()) {
      publishProgress(syncName,res.getString(R.string.sync_summary_from_server_message));
      JSONArray sums=client.summaries();
      if (client.needFullSync(sums)) {
        Log.i(TAG,"DECK NEEDS FULL SYNC");
        publishProgress(syncName,res.getString(R.string.sync_preparing_full_sync_message));
        String syncFrom=client.prepareFullSync();
        if ("fromLocal".equalsIgnoreCase(syncFrom)) {
          publishProgress(syncName,res.getString(R.string.sync_uploading_message));
          SyncClient.fullSyncFromLocal(password,username,syncName,deckPath);
        }
 else         if ("fromServer".equalsIgnoreCase(syncFrom)) {
          publishProgress(syncName,res.getString(R.string.sync_downloading_message));
          SyncClient.fullSyncFromServer(password,username,syncName,deckPath);
        }
        ankiDB.database.setTransactionSuccessful();
        ankiDB.database.endTransaction();
        deck.closeDeck();
        deck=Deck.openDeck(deckPath);
        client.setDeck(deck);
        publishProgress(syncName,res.getString(R.string.sync_complete_message));
      }
 else {
        Log.i(TAG,"DECK DOES NOT NEED FULL SYNC");
        publishProgress(syncName,res.getString(R.string.sync_determining_differences_message));
        JSONObject payload=client.genPayload(sums);
        publishProgress(syncName,res.getString(R.string.sync_transferring_payload_message));
        JSONObject payloadReply=client.getServer().applyPayload(payload);
        publishProgress(syncName,res.getString(R.string.sync_applying_reply_message));
        client.applyPayloadReply(payloadReply);
        deck.lastLoaded=deck.modified;
        deck.commitToDB();
        ankiDB.database.setTransactionSuccessful();
        publishProgress(syncName,res.getString(R.string.sync_complete_message));
      }
    }
 else {
      Log.i(TAG,"NO CHANGES.");
      publishProgress(syncName,res.getString(R.string.sync_no_changes_message));
    }
  }
 catch (  Exception e) {
    data.success=false;
    data.exception=e;
    Log.e(TAG,"Error synchronizing deck = " + e.getMessage());
    e.printStackTrace();
  }
 finally {
    if (ankiDB.database != null && ankiDB.database.inTransaction()) {
      ankiDB.database.endTransaction();
    }
    if (deck != null) {
      deck.closeDeck();
    }
  }
  return data;
}
