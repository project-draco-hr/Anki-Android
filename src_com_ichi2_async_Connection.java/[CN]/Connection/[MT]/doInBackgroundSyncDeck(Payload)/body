{
  publishProgress(CurrentProgress+=10,context.getResources().getString(R.string.starting_db_transaction));
  AnkiDb.database.beginTransaction();
  try {
    String username=(String)data.data[0];
    String password=(String)data.data[1];
    Deck deck=(Deck)data.data[2];
    String deckPath=(String)data.data[3];
    String syncName=deck.getSyncName();
    Log.i(TAG,"Starting sync: username = " + username + ", password = "+ password+ ", deckPath = "+ deckPath+ ", syncName = "+ syncName);
    AnkiDroidProxy server=new AnkiDroidProxy(username,password);
    publishProgress(CurrentProgress+=10,context.getResources().getString(R.string.connecting_to_server));
    server.connect();
    if (!server.hasDeck(syncName)) {
      Log.i(TAG,"AnkiOnline does not have this deck: Creating it...");
      publishProgress(CurrentProgress+=10,context.getResources().getString(R.string.creating_deck_at_server));
      server.createDeck(syncName);
    }
    int timediff=(int)(server.getTimestamp() - (System.currentTimeMillis() / 1000));
    if (timediff > 300) {
      Log.i(TAG,"");
    }
    SyncClient client=new SyncClient(deck);
    client.setServer(server);
    server.setDeckName(syncName);
    if (client.prepareSync()) {
      publishProgress(CurrentProgress+=10,context.getResources().getString(R.string.calculating_summaries));
      JSONArray sums=client.summaries();
      publishProgress(CurrentProgress+=10,context.getResources().getString(R.string.determining_sync_type));
      if (client.needFullSync(sums)) {
        Log.i(TAG,"DECK NEEDS FULL SYNC");
        String syncFrom=client.prepareFullSync();
        publishProgress(CurrentProgress+=10,context.getResources().getString(R.string.performing_full_sync));
        if ("fromLocal".equalsIgnoreCase(syncFrom)) {
          SyncClient.fullSyncFromLocal(password,username,syncName,deckPath);
        }
 else         if ("fromServer".equalsIgnoreCase(syncFrom)) {
          SyncClient.fullSyncFromServer(password,username,syncName,deckPath);
        }
        publishProgress(CurrentProgress+=10,context.getResources().getString(R.string.setting_db_transaction_success));
        AnkiDb.database.setTransactionSuccessful();
        publishProgress(CurrentProgress+=10,context.getResources().getString(R.string.finishing_db_transaction));
        AnkiDb.database.endTransaction();
        publishProgress(CurrentProgress+=10,context.getResources().getString(R.string.closing_deck));
        deck.closeDeck();
        publishProgress(CurrentProgress+=10,context.getResources().getString(R.string.opening_deck_after_sync));
        deck=Deck.openDeck(deckPath);
        publishProgress(CurrentProgress+=10,context.getResources().getString(R.string.setting_deck_as_current));
        client.setDeck(deck);
      }
 else {
        Log.i(TAG,"DECK DOES NOT NEED FULL SYNC");
        publishProgress(CurrentProgress+=10,context.getResources().getString(R.string.generating_payload));
        JSONObject payload=client.genPayload(sums);
        publishProgress(CurrentProgress+=10,context.getResources().getString(R.string.getting_payload_reply));
        JSONObject payloadReply=client.getServer().applyPayload(payload);
        publishProgress(CurrentProgress+=10,context.getResources().getString(R.string.applying_payload_reply));
        client.applyPayloadReply(payloadReply);
        publishProgress(CurrentProgress+=10,context.getResources().getString(R.string.commiting_payload_to_db));
        deck.lastLoaded=deck.modified;
        deck.commitToDB();
        publishProgress(CurrentProgress+=10,context.getResources().getString(R.string.setting_db_transaction_success));
        AnkiDb.database.setTransactionSuccessful();
      }
    }
 else {
      Log.i(TAG,"NO CHANGES.");
    }
  }
 catch (  Exception e) {
    data.success=false;
    data.exception=e;
    Log.e(TAG,"Error synchronizing deck = " + e.getMessage());
    e.printStackTrace();
  }
 finally {
    if (AnkiDb.database.inTransaction()) {
      publishProgress(CurrentProgress+=10,context.getResources().getString(R.string.finishing_db_transaction));
      AnkiDb.database.endTransaction();
    }
  }
  return data;
}
