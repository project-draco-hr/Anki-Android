{
  Resources res=sContext.getResources();
  HashMap<String,String> syncChangelog=new HashMap<String,String>();
  String username=(String)data.data[0];
  String password=(String)data.data[1];
  Deck deck=(Deck)data.data[2];
  String deckPath=(String)data.data[3];
  String syncName=deckPath.substring(deckPath.lastIndexOf("/") + 1,deckPath.length() - 5);
  String conflictResolution=(String)data.data[4];
  if (deck == null) {
    publishProgress(syncName,res.getString(R.string.sync_set_journal_mode));
    deck=Deck.openDeck(deckPath,true,true);
  }
  syncChangelog.put("deckName",syncName);
  AnkiDb ankiDB=AnkiDatabaseManager.getDatabase(deckPath);
  ankiDB.getDatabase().beginTransaction();
  try {
    AnkiDroidProxy server=new AnkiDroidProxy(username,password);
    publishProgress(syncName,res.getString(R.string.sync_connecting_message));
    int connectResult=server.connect(true);
    if (connectResult != AnkiDroidProxy.LOGIN_OK) {
      if (connectResult == AnkiDroidProxy.LOGIN_INVALID_USER_PASS) {
        syncChangelog.put("message",res.getString(R.string.invalid_username_password));
      }
 else       if (connectResult == AnkiDroidProxy.LOGIN_CLOCKS_UNSYNCED) {
        double diff=server.getTimediff();
        if (Math.abs(diff) >= 86400.0) {
          syncChangelog.put("message",res.getString(R.string.sync_log_clocks_unsynchronized,((long)diff),res.getString(R.string.sync_log_clocks_unsynchronized_date)));
        }
 else         if (Math.abs((Math.abs(diff) % 3600.0) - 1800.0) >= 1500.0) {
          syncChangelog.put("message",res.getString(R.string.sync_log_clocks_unsynchronized,((long)diff),res.getString(R.string.sync_log_clocks_unsynchronized_tz)));
        }
 else {
          syncChangelog.put("message",res.getString(R.string.sync_log_clocks_unsynchronized,((long)diff),""));
        }
      }
 else       if (connectResult == AnkiDroidProxy.LOGIN_OLD_VERSION) {
        syncChangelog.put("message",String.format(res.getString(R.string.sync_log_old_version),res.getString(R.string.link_ankidroid)));
      }
 else       if (connectResult == AnkiDroidProxy.LOGIN_TOO_BUSY) {
        syncChangelog.put("message",res.getString(R.string.sync_too_busy));
      }
 else {
        syncChangelog.put("message",res.getString(R.string.login_generic_error));
      }
      data.result=syncChangelog;
      data.success=false;
      ankiDB.getDatabase().endTransaction();
      return data;
    }
    if (!server.hasDeck(syncName)) {
      Log.i(AnkiDroidApp.TAG,"AnkiOnline does not have this deck: Creating it...");
      Payload result=server.createDeck(syncName);
      if (result.success != true) {
        syncChangelog.put("message",res.getString(R.string.sync_log_create_deck_failed,((String)result.result)));
        result.result=syncChangelog;
        ankiDB.getDatabase().endTransaction();
        return result;
      }
    }
    publishProgress(syncName,res.getString(R.string.sync_syncing_message,new Object[]{syncName}));
    SyncClient client=new SyncClient(deck);
    client.setServer(server);
    server.setDeckName(syncName);
    double localMod=deck.getModified();
    double localSync=deck.getLastSync();
    double remoteMod=server.modified();
    double remoteSync=server.lastSync();
    if (remoteMod < 0 || remoteSync < 0) {
      data.success=false;
      syncChangelog.put("message",res.getString(R.string.sync_log_error_message));
      data.result=syncChangelog;
      ankiDB.getDatabase().endTransaction();
      return data;
    }
    double minSync=Math.min(localSync,remoteSync);
    if ((localMod != remoteMod) && (minSync > 0) && (localMod > minSync)&& (remoteMod > minSync)) {
      if (conflictResolution == null) {
        Log.i(AnkiDroidApp.TAG,"Syncing needs conflict resolution user input...");
        data.success=false;
        data.returnType=AnkiDroidProxy.SYNC_CONFLICT_RESOLUTION;
        syncChangelog.put("message",res.getString(R.string.sync_log_conflict_resolution_required));
        data.result=syncChangelog;
        return data;
      }
    }
    if (client.prepareSync(server.getTimediff())) {
      if (deck.getLastSync() <= 0) {
        if (client.getRemoteTime() > client.getLocalTime()) {
          conflictResolution="keepRemote";
        }
 else {
          conflictResolution="keepLocal";
        }
      }
      JSONArray sums=null;
      if (conflictResolution == null) {
        publishProgress(syncName,res.getString(R.string.sync_summary_from_server_message));
        sums=client.summaries();
        if (sums == null) {
          data.success=false;
          syncChangelog.put("message",res.getString(R.string.sync_log_error_message));
          data.result=syncChangelog;
          ankiDB.getDatabase().endTransaction();
          return data;
        }
      }
      if ((conflictResolution != null) || client.needFullSync(sums)) {
        Log.i(AnkiDroidApp.TAG,"DECK NEEDS FULL SYNC");
        publishProgress(syncName,res.getString(R.string.sync_preparing_full_sync_message));
        if (conflictResolution != null) {
          if (conflictResolution.equals("keepLocal")) {
            client.setRemoteTime(0.0);
          }
 else           if (conflictResolution.equals("keepRemote")) {
            client.setLocalTime(0.0);
          }
        }
        String syncFrom=client.prepareFullSync();
        HashMap<String,String> result=new HashMap<String,String>();
        if ("fromLocal".equalsIgnoreCase(syncFrom)) {
          publishProgress(syncName,res.getString(R.string.sync_uploading_message));
          result=SyncClient.fullSyncFromLocal(password,username,deck,syncName);
          if (result.containsKey("code") && result.get("code").equals("200")) {
            syncChangelog.put("message",res.getString(R.string.sync_log_uploading_message));
          }
          ankiDB.getDatabase().setTransactionSuccessful();
          ankiDB.getDatabase().endTransaction();
        }
 else         if ("fromServer".equalsIgnoreCase(syncFrom)) {
          publishProgress(syncName,res.getString(R.string.sync_downloading_message));
          ankiDB.getDatabase().endTransaction();
          if (deck != null) {
            deck.closeDeck();
          }
          result=SyncClient.fullSyncFromServer(password,username,syncName,deckPath);
          if (result.containsKey("code") && result.get("code").equals("200")) {
            syncChangelog.put("message",res.getString(R.string.sync_log_downloading_message));
          }
        }
        publishProgress(syncName,res.getString(R.string.sync_complete_message));
        if (!result.containsKey("code") || !result.get("code").equals("200")) {
          if (result.containsKey("message")) {
            syncChangelog.put("message",String.format(res.getString(R.string.sync_log_error_specific),result.get("code"),result.get("message")));
          }
 else {
            syncChangelog.put("message",res.getString(R.string.sync_log_error_message));
          }
        }
      }
 else {
        Log.i(AnkiDroidApp.TAG,"DECK DOES NOT NEED FULL SYNC");
        publishProgress(syncName,res.getString(R.string.sync_determining_differences_message));
        JSONObject payload=client.genPayload(sums);
        int factsAddedOnLocal=payload.getJSONArray("added-cards").length();
        if (factsAddedOnLocal > 0) {
          syncChangelog.put("message",res.getQuantityString(R.plurals.sync_log_facts_to_server_message,factsAddedOnLocal,factsAddedOnLocal));
        }
        publishProgress(syncName,res.getString(R.string.sync_transferring_payload_message));
        JSONObject payloadReply=client.getServer().applyPayload(payload);
        if (payloadReply == null) {
          data.success=false;
          syncChangelog.put("message",res.getString(R.string.sync_log_error_message));
          data.result=syncChangelog;
          ankiDB.getDatabase().endTransaction();
          return data;
        }
        int factsAddedOnServer=payloadReply.getJSONArray("added-cards").length();
        if (factsAddedOnLocal == 0 && factsAddedOnServer == 0) {
          syncChangelog.put("message",res.getString(R.string.sync_log_zero_facts));
        }
 else         if (factsAddedOnServer > 0) {
          syncChangelog.put("message",res.getQuantityString(R.plurals.sync_log_facts_from_server_message,factsAddedOnServer,factsAddedOnServer));
        }
        publishProgress(syncName,res.getString(R.string.sync_applying_reply_message));
        client.applyPayloadReply(payloadReply);
        deck.initDeckvarsCache();
        Reviewer.setupMedia(deck);
        SharedPreferences preferences=PrefSettings.getSharedPrefs(sContext);
        if (preferences.getBoolean("syncFetchMedia",true)) {
          doInBackgroundDownloadMissingMedia(new Payload(new Object[]{deck}));
        }
        if (!client.getServer().finish()) {
          data.success=false;
          syncChangelog.put("message",res.getString(R.string.sync_log_finish_error));
          data.result=syncChangelog;
          ankiDB.getDatabase().endTransaction();
          return data;
        }
        deck.reset();
        deck.setLastLoaded(deck.getModified());
        deck.commitToDB();
        Log.i(AnkiDroidApp.TAG,String.format(Utils.ENGLISH_LOCALE,"Modified: %f, LastSync: %f, LastLoaded: %f",deck.getModified(),deck.getLastSync(),deck.getLastLoaded()));
        ankiDB.getDatabase().setTransactionSuccessful();
        publishProgress(syncName,res.getString(R.string.sync_complete_message));
      }
    }
 else {
      Log.i(AnkiDroidApp.TAG,"NO CHANGES.");
      publishProgress(syncName,res.getString(R.string.sync_no_changes_message));
      syncChangelog.put("message",res.getString(R.string.sync_log_no_changes_message));
    }
  }
 catch (  OutOfMemoryError e) {
    Log.e(AnkiDroidApp.TAG,"doInBackgroundSyncDeck - JSONException: " + e.getMessage());
    Log.e(AnkiDroidApp.TAG,Log.getStackTraceString(e));
    syncChangelog.put("message",res.getString(R.string.sync_log_error_message));
    data.success=false;
  }
catch (  JSONException e) {
    Log.e(AnkiDroidApp.TAG,"doInBackgroundSyncDeck - JSONException: " + e.getMessage());
    Log.e(AnkiDroidApp.TAG,Log.getStackTraceString(e));
    syncChangelog.put("message",res.getString(R.string.sync_log_error_message));
    data.success=false;
    data.exception=e;
  }
 finally {
    if (ankiDB.getDatabase() != null && ankiDB.getDatabase().inTransaction()) {
      ankiDB.getDatabase().endTransaction();
    }
    if (deck != null) {
      deck.closeDeck();
    }
  }
  data.result=syncChangelog;
  return data;
}
