{
  Resources res=sContext.getResources();
  HashMap<String,String> syncChangelog=new HashMap<String,String>();
  String username=(String)data.data[0];
  String password=(String)data.data[1];
  Deck deck=(Deck)data.data[2];
  String deckPath=(String)data.data[3];
  String syncName=deckPath.substring(deckPath.lastIndexOf("/") + 1,deckPath.length() - 5);
  syncChangelog.put("deckName",syncName);
  AnkiDb ankiDB=AnkiDatabaseManager.getDatabase(deckPath);
  ankiDB.getDatabase().beginTransaction();
  try {
    AnkiDroidProxy server=new AnkiDroidProxy(username,password);
    publishProgress(syncName,res.getString(R.string.sync_connecting_message));
    int connectResult=server.connect();
    if (connectResult != AnkiDroidProxy.LOGIN_OK) {
      if (connectResult == AnkiDroidProxy.LOGIN_INVALID_USER_PASS) {
        syncChangelog.put("message",res.getString(R.string.invalid_username_password));
      }
 else       if (connectResult == AnkiDroidProxy.LOGIN_CLOCKS_UNSYNCED) {
        syncChangelog.put("message",String.format(res.getString(R.string.sync_log_clocks_unsynchronized),(new Double(server.getTimediff())).longValue()));
      }
      data.result=syncChangelog;
      data.success=false;
      return data;
    }
    if (!server.hasDeck(syncName)) {
      Log.i(AnkiDroidApp.TAG,"AnkiOnline does not have this deck: Creating it...");
      server.createDeck(syncName);
    }
    publishProgress(syncName,res.getString(R.string.sync_syncing_message,new Object[]{syncName}));
    SyncClient client=new SyncClient(deck);
    client.setServer(server);
    server.setDeckName(syncName);
    String conflictResolution=null;
    if (client.prepareSync(server.getTimediff())) {
      if (deck.getLastSync() <= 0) {
        if (client.getRemoteTime() > client.getLocalTime()) {
          conflictResolution="keepRemote";
        }
 else {
          conflictResolution="keepLocal";
        }
      }
      JSONArray sums=null;
      if (conflictResolution == null) {
        publishProgress(syncName,res.getString(R.string.sync_summary_from_server_message));
        sums=client.summaries();
      }
      if ((conflictResolution != null) || client.needFullSync(sums)) {
        Log.i(AnkiDroidApp.TAG,"DECK NEEDS FULL SYNC");
        publishProgress(syncName,res.getString(R.string.sync_preparing_full_sync_message));
        if (conflictResolution != null) {
          if (conflictResolution.equals("keepLocal")) {
            client.setRemoteTime(0.0);
          }
 else           if (conflictResolution.equals("keepRemote")) {
            client.setLocalTime(0.0);
          }
        }
        String syncFrom=client.prepareFullSync();
        if ("fromLocal".equalsIgnoreCase(syncFrom)) {
          publishProgress(syncName,res.getString(R.string.sync_uploading_message));
          SyncClient.fullSyncFromLocal(password,username,deck,syncName);
          syncChangelog.put("message",res.getString(R.string.sync_log_uploading_message));
          ankiDB.getDatabase().setTransactionSuccessful();
          ankiDB.getDatabase().endTransaction();
        }
 else         if ("fromServer".equalsIgnoreCase(syncFrom)) {
          publishProgress(syncName,res.getString(R.string.sync_downloading_message));
          ankiDB.getDatabase().endTransaction();
          if (deck != null) {
            deck.closeDeck();
          }
          SyncClient.fullSyncFromServer(password,username,syncName,deckPath);
          syncChangelog.put("message",res.getString(R.string.sync_log_downloading_message));
        }
        publishProgress(syncName,res.getString(R.string.sync_complete_message));
      }
 else {
        Log.i(AnkiDroidApp.TAG,"DECK DOES NOT NEED FULL SYNC");
        publishProgress(syncName,res.getString(R.string.sync_determining_differences_message));
        JSONObject payload=client.genPayload(sums);
        int factsAddedOnLocal=payload.getJSONArray("added-cards").length();
        if (factsAddedOnLocal == 1) {
          syncChangelog.put("message",res.getString(R.string.sync_log_fact_to_server_message));
        }
 else         if (factsAddedOnLocal > 1) {
          syncChangelog.put("message",res.getString(R.string.sync_log_facts_to_server_message,factsAddedOnLocal));
        }
        publishProgress(syncName,res.getString(R.string.sync_transferring_payload_message));
        JSONObject payloadReply=client.getServer().applyPayload(payload);
        int factsAddedOnServer=payloadReply.getJSONArray("added-cards").length();
        if (factsAddedOnServer == 1) {
          syncChangelog.put("message",res.getString(R.string.sync_log_fact_from_server_message));
        }
 else         if (payloadReply.getJSONArray("added-cards").length() > 1) {
          syncChangelog.put("message",res.getString(R.string.sync_log_facts_from_server_message,factsAddedOnServer));
        }
        publishProgress(syncName,res.getString(R.string.sync_applying_reply_message));
        client.applyPayloadReply(payloadReply);
        client.getServer().finish();
        deck.reset();
        deck.setLastLoaded(deck.getModified());
        deck.commitToDB();
        Log.i(AnkiDroidApp.TAG,String.format(Utils.ENGLISH_LOCALE,"Modified: %f, LastSync: %f, LastLoaded: %f",deck.getModified(),deck.getLastSync(),deck.getLastLoaded()));
        ankiDB.getDatabase().setTransactionSuccessful();
        publishProgress(syncName,res.getString(R.string.sync_complete_message));
      }
    }
 else {
      Log.i(AnkiDroidApp.TAG,"NO CHANGES.");
      publishProgress(syncName,res.getString(R.string.sync_no_changes_message));
      syncChangelog.put("message",res.getString(R.string.sync_log_no_changes_message));
    }
  }
 catch (  Exception e) {
    Log.e(AnkiDroidApp.TAG,"Error synchronizing deck = " + e.getMessage());
    e.printStackTrace();
    syncChangelog.put("message",res.getString(R.string.sync_log_error_message));
    data.success=false;
    data.exception=e;
  }
 finally {
    if (ankiDB.getDatabase() != null && ankiDB.getDatabase().inTransaction()) {
      ankiDB.getDatabase().endTransaction();
    }
    if (deck != null) {
      deck.closeDeck();
    }
  }
  data.result=syncChangelog;
  return data;
}
