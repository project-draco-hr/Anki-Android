{
  String path=(String)data.data[0];
  File ankiDir=new File(path);
  if (!ankiDir.isDirectory()) {
    data.success=false;
    data.data=new Object[]{"wrong anki directory"};
    return data;
  }
  File[] fileList=ankiDir.listFiles(new OldAnkiDeckFilter());
  JSONObject map=new JSONObject();
  byte[] buf=new byte[1024];
  String zipFilename=path + "/upload.zip";
  String colFilename=path + "/collection.anki2";
  try {
    ZipOutputStream zos=new ZipOutputStream(new FileOutputStream(zipFilename));
    int n=1;
    for (    File f : fileList) {
      String deckPath=f.getAbsolutePath();
      try {
        AnkiDb d=AnkiDatabaseManager.getDatabase(deckPath);
        d.queryString("PRAGMA journal_mode = DELETE");
      }
  finally {
        AnkiDatabaseManager.closeDatabase(deckPath);
      }
      String tmpName=n + ".anki";
      FileInputStream in=new FileInputStream(deckPath);
      ZipEntry ze=new ZipEntry(tmpName);
      zos.putNextEntry(ze);
      int len;
      while ((len=in.read(buf)) > 0) {
        zos.write(buf,0,len);
      }
      zos.closeEntry();
      map.put(tmpName,f.getName());
      n++;
    }
    ZipEntry ze=new ZipEntry("map.json");
    zos.putNextEntry(ze);
    InputStream in=new ByteArrayInputStream(map.toString().getBytes("UTF-8"));
    int len;
    while ((len=in.read(buf)) > 0) {
      zos.write(buf,0,len);
    }
    zos.closeEntry();
    zos.close();
  }
 catch (  FileNotFoundException e) {
    throw new RuntimeException(e);
  }
catch (  IOException e) {
    throw new RuntimeException(e);
  }
catch (  JSONException e) {
    throw new RuntimeException(e);
  }
  File zipFile=new File(zipFilename);
  if (zipFile.length() > 50 * 1024 * 1024) {
    data.success=false;
    data.data=new Object[]{"more than 50 mb, please upgrade via desktop"};
    return data;
  }
  BasicHttpSyncer h=new BasicHttpSyncer(null,null);
  publishProgress(new Object[]{R.string.upgrade_decks_upload});
  try {
    HttpResponse resp=h.req("upgrade/upload",new FileInputStream(zipFile),0,false);
    if (resp == null) {
      data.success=false;
      data.data=new Object[]{"error when uploading"};
      return data;
    }
    String result=h.stream2String(resp.getEntity().getContent());
    String key;
    if (result.startsWith("ok:")) {
      key=result.split(":")[1];
    }
 else {
      data.success=false;
      data.data=new Object[]{"error when uploading"};
      return data;
    }
    while (true) {
      result=h.stream2String(h.req("upgrade/status?key=" + key).getEntity().getContent());
      if (result.equals("error")) {
        data.success=false;
        data.data=new Object[]{"error"};
        return data;
      }
 else       if (result.startsWith("waiting:")) {
        publishProgress(new Object[]{R.string.upgrade_decks_upload,result.split(":")[1]});
      }
 else       if (result.equals("upgrading")) {
        publishProgress(new Object[]{R.string.upgrade_decks_upgrade_started});
      }
 else       if (result.equals("ready")) {
        break;
      }
 else {
        data.success=false;
        data.data=new Object[]{"error"};
        return data;
      }
      Thread.sleep(1000);
    }
    publishProgress(new Object[]{R.string.upgrade_decks_downloading});
    resp=h.req("upgrade/download?key=" + key);
    if (resp == null) {
      data.success=false;
      data.data=new Object[]{"error downloading file"};
      return data;
    }
    InputStream cont=resp.getEntity().getContent();
    if (!h.writeToFile(cont,colFilename)) {
      data.success=false;
      data.data=new Object[]{"error writing on the sd card"};
      (new File(colFilename)).delete();
      return data;
    }
    publishProgress(new Object[]{R.string.sync_check_download_file});
    publishProgress(R.string.sync_check_download_file);
    try {
      AnkiDb d=AnkiDatabaseManager.getDatabase(colFilename);
      if (!d.queryString("PRAGMA integrity_check").equalsIgnoreCase("ok")) {
        data.success=false;
        data.data=new Object[]{"downloaded file was corrupt"};
        return data;
      }
    }
  finally {
      AnkiDatabaseManager.closeDatabase(colFilename);
    }
    Collection col=AnkiDroidApp.openCollection(colFilename);
    ArrayList<String> decks=col.getDecks().allNames(false);
    ArrayList<String> failed=new ArrayList<String>();
    for (    File f : fileList) {
      String name=f.getName().replace(".anki","");
      if (!decks.contains(name)) {
        failed.add(name);
      }
    }
    AnkiDroidApp.closeCollection(false);
    data.data=new Object[]{failed};
    data.success=true;
    return data;
  }
 catch (  FileNotFoundException e) {
    throw new RuntimeException(e);
  }
catch (  InterruptedException e) {
    throw new RuntimeException(e);
  }
catch (  IllegalStateException e) {
    throw new RuntimeException(e);
  }
catch (  IOException e) {
    throw new RuntimeException(e);
  }
 finally {
    (new File(zipFilename)).delete();
  }
}
