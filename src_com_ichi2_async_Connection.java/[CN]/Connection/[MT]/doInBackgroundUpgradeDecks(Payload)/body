{
  mCancelCallback=new CancelCallback();
  String path=(String)data.data[0];
  File ankiDir=new File(path);
  if (!ankiDir.isDirectory()) {
    data.success=false;
    data.data=new Object[]{"wrong anki directory"};
    return data;
  }
  File[] fileList=ankiDir.listFiles(new OldAnkiDeckFilter());
  JSONObject map=new JSONObject();
  byte[] buf=new byte[1024];
  String zipFilename=path + "/upload.zip";
  String colFilename=path + AnkiDroidApp.COLLECTION_PATH;
  try {
    ZipOutputStream zos=new ZipOutputStream(new FileOutputStream(zipFilename));
    int n=1;
    for (    File f : fileList) {
      String deckPath=f.getAbsolutePath();
      try {
        AnkiDb d=AnkiDatabaseManager.getDatabase(deckPath);
        d.queryString("PRAGMA journal_mode = DELETE");
      }
  finally {
        AnkiDatabaseManager.closeDatabase(deckPath);
      }
      String tmpName=n + ".anki";
      FileInputStream in=new FileInputStream(deckPath);
      ZipEntry ze=new ZipEntry(tmpName);
      zos.putNextEntry(ze);
      int len;
      while ((len=in.read(buf)) >= 0) {
        zos.write(buf,0,len);
      }
      zos.closeEntry();
      map.put(tmpName,f.getName());
      n++;
    }
    ZipEntry ze=new ZipEntry("map.json");
    zos.putNextEntry(ze);
    InputStream in=new ByteArrayInputStream(Utils.jsonToString(map).getBytes("UTF-8"));
    int len;
    while ((len=in.read(buf)) >= 0) {
      zos.write(buf,0,len);
    }
    zos.closeEntry();
    zos.close();
  }
 catch (  FileNotFoundException e) {
    throw new RuntimeException(e);
  }
catch (  IOException e) {
    throw new RuntimeException(e);
  }
catch (  JSONException e) {
    throw new RuntimeException(e);
  }
  File zipFile=new File(zipFilename);
  if (zipFile.length() > 50 * 1024 * 1024) {
    data.success=false;
    data.data=new Object[]{"more than 50 mb, please upgrade via desktop"};
    return data;
  }
  BasicHttpSyncer h=new BasicHttpSyncer(null,null);
  publishProgress(new Object[]{R.string.upgrade_decks_upload,null,true});
  try {
    HttpResponse resp=h.req("upgrade/upload",new FileInputStream(zipFile),0,false,null,mCancelCallback);
    if (resp == null && !isCancelled()) {
      data.success=false;
      data.data=new Object[]{"error when uploading"};
      return data;
    }
    String result;
    String key=null;
    if (!isCancelled()) {
      result=h.stream2String(resp.getEntity().getContent());
      if (result != null && result.startsWith("ok:")) {
        key=result.split(":")[1];
      }
 else {
        data.success=false;
        data.data=new Object[]{"error when uploading"};
        return data;
      }
    }
    while (true && !isCancelled()) {
      result=h.stream2String(h.req("upgrade/status?key=" + key).getEntity().getContent());
      if (result.equals("error")) {
        data.success=false;
        data.data=new Object[]{"error"};
        return data;
      }
 else       if (result.startsWith("waiting:")) {
        publishProgress(new Object[]{R.string.upgrade_decks_upload,result.split(":")[1]});
      }
 else       if (result.equals("upgrading")) {
        publishProgress(new Object[]{R.string.upgrade_decks_upgrade_started});
      }
 else       if (result.equals("ready")) {
        break;
      }
 else {
        data.success=false;
        data.data=new Object[]{"error"};
        return data;
      }
      Thread.sleep(1000);
    }
    if (!isCancelled()) {
      publishProgress(new Object[]{R.string.upgrade_decks_downloading});
      resp=h.req("upgrade/download?key=" + key,null,6,true,null,mCancelCallback);
    }
    publishProgress(new Object[]{R.string.upgrade_decks_downloading,null,false});
    if (isCancelled()) {
      data.success=false;
      data.data=new Object[]{"cancelled"};
      return data;
    }
    if (resp == null) {
      data.success=false;
      data.data=new Object[]{"error downloading file"};
      return data;
    }
    InputStream cont=resp.getEntity().getContent();
    if (!h.writeToFile(cont,colFilename)) {
      data.success=false;
      data.data=new Object[]{"error writing on the sd card"};
      (new File(colFilename)).delete();
      return data;
    }
    publishProgress(new Object[]{R.string.sync_check_download_file});
    publishProgress(R.string.sync_check_download_file);
    try {
      AnkiDb d=AnkiDatabaseManager.getDatabase(colFilename);
      if (!d.queryString("PRAGMA integrity_check").equalsIgnoreCase("ok")) {
        data.success=false;
        data.data=new Object[]{"downloaded file was corrupt"};
        return data;
      }
    }
  finally {
      AnkiDatabaseManager.closeDatabase(colFilename);
    }
    Collection col=AnkiDroidApp.openCollection(colFilename);
    ArrayList<String> decks=col.getDecks().allNames(false);
    ArrayList<String> failed=new ArrayList<String>();
    ArrayList<File> mediaDirs=new ArrayList<File>();
    for (    File f : fileList) {
      String name=f.getName().replaceFirst("\\.anki$","");
      if (!decks.contains(name)) {
        failed.add(name);
      }
 else {
        mediaDirs.add(new File(f.getAbsolutePath().replaceFirst("\\.anki$",".media")));
      }
    }
    File newMediaDir=new File(col.getMedia().getDir());
    publishProgress(new Object[]{R.string.upgrade_decks_media});
    ArrayList<String> failedMedia=new ArrayList<String>();
    File curMediaDir=null;
    for (    File mediaDir : mediaDirs) {
      curMediaDir=mediaDir;
      if (!curMediaDir.exists() || !curMediaDir.isDirectory()) {
        curMediaDir=new File(AnkiDroidApp.getDropboxDir(),mediaDir.getName());
        if (!curMediaDir.exists() || !curMediaDir.isDirectory()) {
          continue;
        }
      }
      for (      File m : curMediaDir.listFiles()) {
        try {
          Utils.copyFile(m,new File(newMediaDir,m.getName()));
        }
 catch (        IOException e) {
          failedMedia.add(curMediaDir.getName().replaceFirst("\\.media$",".anki"));
          break;
        }
      }
    }
    data.data=new Object[]{failed,failedMedia,newMediaDir.getAbsolutePath()};
    data.success=true;
    return data;
  }
 catch (  FileNotFoundException e) {
    throw new RuntimeException(e);
  }
catch (  InterruptedException e) {
    throw new RuntimeException(e);
  }
catch (  IllegalStateException e) {
    throw new RuntimeException(e);
  }
catch (  IOException e) {
    throw new RuntimeException(e);
  }
 finally {
    (new File(zipFilename)).delete();
  }
}
